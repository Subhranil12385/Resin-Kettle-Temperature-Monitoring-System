<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resin Kettle Temperature Monitoring Dashboard - CPIL Chennai</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/3.0.1/luxon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-luxon/1.1.0/chartjs-adapter-luxon.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .status-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            padding: 12px 25px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-badge.online {
            background: #10b981;
            color: white;
        }

        .status-badge.offline {
            background: #ef4444;
            color: white;
        }

        .status-badge::before {
            content: '';
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .last-update {
            color: #666;
            font-size: 0.9em;
        }

        .current-temps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .temp-box {
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .temp-box h3 {
            font-size: 0.9em;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .temp-box .value {
            font-size: 2em;
            font-weight: bold;
        }

        .controls-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .controls-card h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .date-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        .control-group input,
        .control-group select {
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-secondary.active {
            background: #667eea;
            color: white;
        }

        .chart-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .chart-card h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 400px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f9fafb;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-item .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-item .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .kettle-selection {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .kettle-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f3f4f6;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .kettle-checkbox:hover {
            background: #e5e7eb;
        }

        .kettle-checkbox input {
            margin: 0;
        }

        .duration-measurement {
            background: #f9fafb;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .duration-measurement h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .duration-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .duration-instruction {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .duration-result {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .duration-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 150px;
        }

        .duration-item .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .duration-item .value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }

        .report-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .report-section h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .report-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-group label {
            font-weight: 600;
            color: #555;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .temp-high-low {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .temp-high-low .high {
            color: #3b82f6;
            font-weight: bold;
        }

        .temp-high-low .low {
            color: #3b82f6;
            font-weight: bold;
        }
        
        .auto-refresh-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .auto-refresh-control label {
            font-weight: 600;
            color: #555;
        }
        
        .others-input {
            margin-top: 8px;
            display: none;
        }
        
        .others-input.show {
            display: block;
        }
        
        .dual-duration-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .measurement-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }
        
        @media (max-width: 768px) {
            .dual-duration-container {
                grid-template-columns: 1fr;
            }
        }
        
        .comment-section {
            margin-top: 20px;
        }
        
        .comment-section textarea {
            width: 100%;
            min-height: 100px;
            resize: vertical;
        }
        
        .measurement-legend {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        .legend-color.m1 {
            background-color: #8b5cf6;
        }
        
        .legend-color.m2 {
            background-color: #f59e0b;
        }
        
        .data-filtering-controls {
            background: #f9fafb;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .data-filtering-controls h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filter-info {
            margin-top: 15px;
            padding: 10px;
            background: #e5e7eb;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .filter-info .removed-count {
            color: #ef4444;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå°Ô∏èResin Kettle Temperature Monitoring Dashboard - CPIL Chennai</h1>
            <p>Real-time monitoring and historical data visualization</p>
        </div>

        <div class="status-card">
            <div class="status-header">
                <div class="status-indicator">
                    <div id="statusBadge" class="status-badge online">
                        <span id="statusText">ONLINE</span>
                    </div>
                </div>
                <div class="last-update">
                    Last Update: <strong id="lastUpdate">--</strong>
                </div>
            </div>

            <div class="current-temps">
                <div class="temp-box" id="tempBox1">
                    <h3>Kettle 1</h3>
                    <div class="value" id="temp1">--¬∞C</div>
                    <div class="temp-high-low">
                        <span class="low" id="lowTemp1">--¬∞C</span>
                        <span class="high" id="highTemp1">--¬∞C</span>
                    </div>
                </div>
                <div class="temp-box" id="tempBox2">
                    <h3>Kettle 2</h3>
                    <div class="value" id="temp2">--¬∞C</div>
                    <div class="temp-high-low">
                        <span class="low" id="lowTemp2">--¬∞C</span>
                        <span class="high" id="highTemp2">--¬∞C</span>
                    </div>
                </div>
                <div class="temp-box" id="tempBox3">
                    <h3>Kettle 3</h3>
                    <div class="value" id="temp3">--¬∞C</div>
                    <div class="temp-high-low">
                        <span class="low" id="lowTemp3">--¬∞C</span>
                        <span class="high" id="highTemp3">--¬∞C</span>
                    </div>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="label">Time Range</div>
                    <div class="value" id="timeRange">--</div>
                </div>
            </div>
        </div>

        <div class="controls-card">
            <h2>üìÖ Date and Time Selection</h2>
            <div class="date-controls">
                <div class="control-group">
                    <label for="startDate">Start Date</label>
                    <input type="date" id="startDate">
                </div>
                <div class="control-group">
                    <label for="startTime">Start Time</label>
                    <input type="time" id="startTime" value="00:00">
                </div>
                <div class="control-group">
                    <label for="endDate">End Date</label>
                    <input type="date" id="endDate">
                </div>
                <div class="control-group">
                    <label for="endTime">End Time</label>
                    <input type="time" id="endTime" value="23:59">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="loadData()">üìä Load Data</button>
                <button class="btn-secondary active" id="todayBtn" onclick="setToday()">Today</button>
                <button class="btn-secondary" id="last24Btn" onclick="setLast24Hours()">Last 24 Hours</button>
                <button class="btn-secondary" id="thisWeekBtn" onclick="setThisWeek()">This Week</button>
            </div>
            <div class="auto-refresh-control">
                <label for="autoRefresh">Auto Refresh:</label>
                <input type="checkbox" id="autoRefresh" onchange="toggleAutoRefresh()">
                <label for="autoRefresh">Enabled</label>
            </div>
        </div>

        <div id="errorMessage" class="error" style="display: none;"></div>

        <div class="chart-card">
            <h2>üìà Temperature Trends</h2>
            
            <div class="kettle-selection">
                <label class="kettle-checkbox">
                    <input type="checkbox" id="kettle1Check" checked>
                    Kettle 1
                </label>
                <label class="kettle-checkbox">
                    <input type="checkbox" id="kettle2Check" checked>
                    Kettle 2
                </label>
                <label class="kettle-checkbox">
                    <input type="checkbox" id="kettle3Check" checked>
                    Kettle 3
                </label>
            </div>
            
            <div class="measurement-buttons">
                <button class="btn-primary" id="measureBtn1" onclick="setActiveMeasurement(1)">Measure Duration 1</button>
                <button class="btn-secondary" id="measureBtn2" onclick="setActiveMeasurement(2)">Measure Duration 2</button>
            </div>
            
            <div class="measurement-legend">
                <div class="legend-item">
                    <div class="legend-color m1"></div>
                    <span>Measurement 1 Points</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color m2"></div>
                    <span>Measurement 2 Points</span>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="tempChart"></canvas>
            </div>
            
            <div class="data-filtering-controls">
                <h3>üîß Data Filtering Options</h3>
                <div class="filter-controls">
                    <div class="control-group">
                        <label for="spikeThreshold">Spike/Fall Detection Threshold</label>




                        <input type="number" id="spikeThreshold" value="10" min="0.0001" max="50" step="0.01">
<!-- increase value according the requirement. that is the threshold by befault  -->


                    </div>
                    <div class="control-group">
                        <label for="enableFiltering">Enable Spike/Fall Filtering</label>




 
<!-- To keep filtering enabled by default, keep "checked" after "enableFiltering"  -->

                        <input type="checkbox" id="enableFiltering" checked>

<!-- To keep filtering disabled by default, remove "checked". The below is the old line -->
<!-- <input type="checkbox" id="enableFiltering" checked> -->





                    </div>
                    <button class="btn-secondary" onclick="filterAndDisplayData()">Apply Filter</button>
                </div>
                <div class="filter-info">
                    <p>Spike/fall filtering removes noisy reading</p>
                    <p>Removed data points: <span class="removed-count" id="removedCount">0</span></p>
                </div>
            </div>
            
            <div class="dual-duration-container">
                <div class="duration-measurement">
                    <h3>‚è±Ô∏è Duration Measurement 1</h3>
                    <div class="duration-instruction">
                        Click on the chart to select two points to measure the time duration between them.
                    </div>
                    <div class="duration-result">
                        <div class="duration-item">
                            <div class="label">Start Time</div>
                            <div class="value" id="startTimeMeasure1">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">End Time</div>
                            <div class="value" id="endTimeMeasure1">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">Duration</div>
                            <div class="value" id="durationMeasure1">--</div>
                        </div>
                    </div>
                </div>
                
                <div class="duration-measurement">
                    <h3>‚è±Ô∏è Click Duration Measurement 2</h3>
                    <div class="duration-instruction">
                        Click on the chart to select two points and measure the time duration between them.
                    </div>
                    <div class="duration-result">
                        <div class="duration-item">
                            <div class="label">Start Time</div>
                            <div class="value" id="startTimeMeasure2">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">End Time</div>
                            <div class="value" id="endTimeMeasure2">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">Duration</div>
                            <div class="value" id="durationMeasure2">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="report-section">
            <h2>üìã Report Generation</h2>
            <div class="report-form">
                <div class="form-group">
                    <label for="graphTitle">Graph Title</label>
                    <input type="text" id="graphTitle" placeholder="e.g., Kettle 1 Temperature Analysis">
                </div>
                <div class="form-group">
                    <label for="kettleNo">Kettle No</label>
                    <select id="kettleNo">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="resinType">Resin</label>
                    <select id="resinType" onchange="toggleOthersInput('resinOthers')">
                        <option value="MF">MF</option>
                        <option value="PF">PF</option>
                        <option value="UF">UMF</option>
                        <option value="Others">Others, Please specify</option>
                    </select>
                    <input type="text" id="resinOthers" class="others-input" placeholder="Specify resin type">
                </div>
                <div class="form-group">
                    <label for="batchNo">Batch No.</label>
                    <input type="text" id="batchNo" placeholder="e.g., 36">
                </div>
                <div class="form-group">
                    <label for="preparedBy">Prepared By</label>
                    <input type="text" id="preparedBy" placeholder="e.g., Mr.XYZ">
                </div>
                <div class="form-group">
                    <label for="batchQuality">Batch Quality</label>
                    <select id="batchQuality" onchange="toggleOthersInput('qualityOthers')">
                        <option value="OK">OK</option>
                        <option value="NOT OK">NOT OK</option>
                        <option value="Others">Others, Please specify</option>
                    </select>
                    <input type="text" id="qualityOthers" class="others-input" placeholder="Specify quality">
                </div>
            </div>
            
            <div class="comment-section">
                <div class="form-group">
                    <label for="reportComment">Additional Comments (Optional)</label>
                    <textarea id="reportComment" placeholder="Add any additional comments here..."></textarea>
                </div>
            </div>
            
            <button class="btn-primary" onclick="downloadGraph()">üì• Download Graph with Report</button>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
    </div>

    <script>
        const SHEET_URL = 'https://script.google.com/macros/s/AKfycbxJZMmRv5j_3yrXKi0DavTHA8VGmccDeBURN8vIemGAmP7OM2teDd5kcyijYLmGm3dI/exec';
        let chart = null;
        let allData = [];
        let filteredData = [];
        let isMeasuring1 = false;
        let isMeasuring2 = false;
        let measureStart1 = null;
        let measureEnd1 = null;
        let measureStart2 = null;
        let measureEnd2 = null;
        let autoRefreshInterval = null;
        let isFirstLoad = true;
        let currentMeasurement = 1; // 1 or 2 for which duration measurement is active
        let highlightedPoints = {
            m1: [],
            m2: []
        };
        let removedSpikesCount = 0;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setToday();
            loadData();
            
            // Add event listeners for kettle checkboxes
            document.getElementById('kettle1Check').addEventListener('change', filterAndDisplayData);
            document.getElementById('kettle2Check').addEventListener('change', filterAndDisplayData);
            document.getElementById('kettle3Check').addEventListener('change', filterAndDisplayData);
            
            // Add event listeners for date/time inputs
            document.getElementById('startDate').addEventListener('change', filterAndDisplayData);
            document.getElementById('startTime').addEventListener('change', filterAndDisplayData);
            document.getElementById('endDate').addEventListener('change', filterAndDisplayData);
            document.getElementById('endTime').addEventListener('change', filterAndDisplayData);
            
            // Add event listener for threshold input
            document.getElementById('spikeThreshold').addEventListener('input', function() {
                document.getElementById('thresholdValue').textContent = this.value;
            });
        });

        function setActiveMeasurement(measurementNum) {
            currentMeasurement = measurementNum;
            updateActiveMeasurementButton();
        }

        function updateActiveMeasurementButton() {
            const btn1 = document.getElementById('measureBtn1');
            const btn2 = document.getElementById('measureBtn2');
            
            if (currentMeasurement === 1) {
                btn1.className = 'btn-primary';
                btn2.className = 'btn-secondary';
            } else {
                btn1.className = 'btn-secondary';
                btn2.className = 'btn-primary';
            }
        }

        function setToday() {
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            document.getElementById('startDate').value = dateStr;
            document.getElementById('endDate').value = dateStr;
            document.getElementById('startTime').value = '00:00';
            document.getElementById('endTime').value = '23:59';
            
            updateActiveButton('today');
            if (!isFirstLoad) {
                filterAndDisplayData();
            }
        }

        function setLast24Hours() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            
            document.getElementById('endDate').value = now.toISOString().split('T')[0];
            document.getElementById('endTime').value = now.toTimeString().substring(0, 5);
            document.getElementById('startDate').value = yesterday.toISOString().split('T')[0];
            document.getElementById('startTime').value = yesterday.toTimeString().substring(0, 5);
            
            updateActiveButton('last24');
            filterAndDisplayData();
        }

        function setThisWeek() {
            const now = new Date();
            const dayOfWeek = now.getDay();
            const startOfWeek = new Date(now);
            startOfWeek.setDate(now.getDate() - dayOfWeek);
            
            document.getElementById('startDate').value = startOfWeek.toISOString().split('T')[0];
            document.getElementById('startTime').value = '00:00';
            document.getElementById('endDate').value = now.toISOString().split('T')[0];
            document.getElementById('endTime').value = '23:59';
            
            updateActiveButton('thisWeek');
            filterAndDisplayData();
        }

        function updateActiveButton(buttonId) {
            // Reset all buttons
            document.getElementById('todayBtn').classList.remove('active');
            document.getElementById('last24Btn').classList.remove('active');
            document.getElementById('thisWeekBtn').classList.remove('active');
            
            // Activate the selected button
            if (buttonId === 'today') {
                document.getElementById('todayBtn').classList.add('active');
            } else if (buttonId === 'last24') {
                document.getElementById('last24Btn').classList.add('active');
            } else if (buttonId === 'thisWeek') {
                document.getElementById('thisWeekBtn').classList.add('active');
            }
        }

        function toggleAutoRefresh() {
            const autoRefreshCheckbox = document.getElementById('autoRefresh');
            
            if (autoRefreshCheckbox.checked) {
                // Start auto refresh
                autoRefreshInterval = setInterval(loadData, 60000); // Refresh every minute
            } else {
                // Stop auto refresh
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
            }
        }

        function toggleOthersInput(inputId) {
            const resinSelect = document.getElementById('resinType');
            const qualitySelect = document.getElementById('batchQuality');
            const resinOthers = document.getElementById('resinOthers');
            const qualityOthers = document.getElementById('qualityOthers');
            
            // Show/hide resin others input
            if (resinSelect.value === 'Others') {
                resinOthers.classList.add('show');
            } else {
                resinOthers.classList.remove('show');
            }
            
            // Show/hide quality others input
            if (qualitySelect.value === 'Others') {
                qualityOthers.classList.add('show');
            } else {
                qualityOthers.classList.remove('show');
            }
        }

        async function loadData() {
            showLoading();
            try {
                // Use the original URL without parameters
                const response = await fetch(SHEET_URL);
                const data = await response.json();
                
                if (data.error) {
                    showError('Error: ' + data.error);
                    return;
                }

                allData = data.values || [];
                
                if (allData.length < 2) {
                    showError('No data available');
                    return;
                }

                updateStatus();
                filterAndDisplayData();
                
                // Mark first load as complete
                isFirstLoad = false;
                
            } catch (error) {
                showError('Failed to load data: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        function updateStatus() {
            if (allData.length < 2) return;

            const lastRow = allData[allData.length - 1];
            const lastTimestamp = parseTimestamp(lastRow[0]);
            const now = new Date();
            const minutesDiff = (now - lastTimestamp) / 1000 / 60;

            const statusBadge = document.getElementById('statusBadge');
            const statusText = document.getElementById('statusText');
            
            if (minutesDiff > 3) {
                statusBadge.className = 'status-badge offline';
                statusText.textContent = 'OFFLINE';
            } else {
                statusBadge.className = 'status-badge online';
                statusText.textContent = 'ONLINE';
            }

            document.getElementById('lastUpdate').textContent = lastTimestamp.toLocaleString();
            
            // Update current temperatures with color coding - FIXED KETTLE 2
            updateTempBox(1, lastRow[1]);
            updateTempBox(2, lastRow[2]); // This was missing - now fixed
            updateTempBox(3, lastRow[3]);
        }

        function updateTempBox(kettleNum, tempValue) {
            const temp = parseFloat(tempValue);
            const tempBox = document.getElementById(`tempBox${kettleNum}`);
            const tempElement = document.getElementById(`temp${kettleNum}`);
            
            if (isNaN(temp)) {
                tempElement.textContent = '--¬∞C';
                tempBox.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                return;
            }
            
            tempElement.textContent = temp.toFixed(2) + '¬∞C';
            
            // Set color based on temperature
            if (temp <= 30) {
                // Green for low temperatures
                tempBox.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            } else if (temp <= 50) {
                // Yellow for medium temperatures
                tempBox.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            } else if (temp <= 70) {
                // Orange for higher temperatures
                tempBox.style.background = 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)';
            } else {
                // Red for very high temperatures
                tempBox.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            }
        }

        function filterAndDisplayData() {
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;

            if (!startDate || !endDate || allData.length < 2) return;

            const startDateTime = new Date(startDate + 'T' + startTime);
            const endDateTime = new Date(endDate + 'T' + endTime);

            // First filter by date/time
            const timeFilteredData = [];
            
            for (let i = 1; i < allData.length; i++) {
                const timestamp = parseTimestamp(allData[i][0]);
                if (timestamp >= startDateTime && timestamp <= endDateTime) {
                    timeFilteredData.push(allData[i]);
                }
            }

            if (timeFilteredData.length === 0) {
                showError('No data found for selected date/time range');
                return;
            }

            // Apply spike filtering if enabled
            const enableFiltering = document.getElementById('enableFiltering').checked;
            if (enableFiltering) {
                filteredData = removeTemperatureSpikesAndFalls(timeFilteredData);
            } else {
                filteredData = timeFilteredData;
                removedSpikesCount = 0;
            }

            hideError();
            updateStats(filteredData);
            updateChart(filteredData);
            
            // Update the removed count display
            document.getElementById('removedCount').textContent = removedSpikesCount;
        }














function removeTemperatureSpikesAndFalls(data) {
    const threshold = parseFloat(document.getElementById('spikeThreshold').value);
    let removedCount = 0;
    
    if (data.length < 3) return data;
    
    // Create a DEEP copy of the data to work with - don't modify the input
    const filteredData = data.map(row => [...row]);
    
    // Check for spikes and falls in each kettle column
    for (let col = 1; col <= 3; col++) {
        for (let i = 1; i < filteredData.length - 1; i++) {
            const prevTemp = parseFloat(filteredData[i-1][col]);
            const currTemp = parseFloat(filteredData[i][col]);
            const nextTemp = parseFloat(filteredData[i+1][col]);
            
            // Skip if any temperature is invalid
            if (isNaN(prevTemp) || isNaN(currTemp) || isNaN(nextTemp)) continue;
            
            // Calculate temperature differences (absolute values)
            const diffPrev = Math.abs(currTemp - prevTemp);
            const diffNext = Math.abs(currTemp - nextTemp);
            
            // If both differences exceed threshold, it's likely a spike or fall
            if (diffPrev > threshold && diffNext > threshold) {
                // Replace the spike/fall with an interpolated value
                filteredData[i][col] = ((prevTemp + nextTemp) / 2).toFixed(2);
                removedCount++;
            }
        }
    }
    
    removedSpikesCount = removedCount;
    return filteredData;
}






























        function updateStats(data) {
            if (data.length > 0) {
                const firstTime = parseTimestamp(data[0][0]);
                const lastTime = parseTimestamp(data[data.length - 1][0]);
                const hours = ((lastTime - firstTime) / 1000 / 60 / 60).toFixed(1);
                document.getElementById('timeRange').textContent = hours + 'h';

                // Calculate high and low temperatures for each kettle
                const highLow1 = calculateHighLow(data, 1);
                const highLow2 = calculateHighLow(data, 2);
                const highLow3 = calculateHighLow(data, 3);

                document.getElementById('highTemp1').textContent = highLow1.high.toFixed(2) + '¬∞C';
                document.getElementById('lowTemp1').textContent = highLow1.low.toFixed(2) + '¬∞C';
                document.getElementById('highTemp2').textContent = highLow2.high.toFixed(2) + '¬∞C';
                document.getElementById('lowTemp2').textContent = highLow2.low.toFixed(2) + '¬∞C';
                document.getElementById('highTemp3').textContent = highLow3.high.toFixed(2) + '¬∞C';
                document.getElementById('lowTemp3').textContent = highLow3.low.toFixed(2) + '¬∞C';
            }
        }

        function calculateHighLow(data, colIndex) {
            let high = -Infinity;
            let low = Infinity;
            
            for (let row of data) {
                const val = parseFloat(row[colIndex]);
                if (!isNaN(val)) {
                    if (val > high) high = val;
                    if (val < low) low = val;
                }
            }
            
            return {
                high: high !== -Infinity ? high : 0,
                low: low !== Infinity ? low : 0
            };
        }

        function updateChart(data) {
            const kettle1Checked = document.getElementById('kettle1Check').checked;
            const kettle2Checked = document.getElementById('kettle2Check').checked;
            const kettle3Checked = document.getElementById('kettle3Check').checked;

            const timestamps = [];
            const temp1Data = [];
            const temp2Data = [];
            const temp3Data = [];

            // Create arrays to track highlighted points
            const temp1Highlight = [];
            const temp2Highlight = [];
            const temp3Highlight = [];

            for (let row of data) {
                const timestamp = parseTimestamp(row[0]);
                timestamps.push(timestamp.toISOString());
                
                const temp1 = kettle1Checked ? (parseFloat(row[1]) || null) : null;
                const temp2 = kettle2Checked ? (parseFloat(row[2]) || null) : null;
                const temp3 = kettle3Checked ? (parseFloat(row[3]) || null) : null;
                
                temp1Data.push(temp1);
                temp2Data.push(temp2);
                temp3Data.push(temp3);
                
                // Check if this point should be highlighted
                const isM1Point = isHighlightedPoint(timestamp, 'm1');
                const isM2Point = isHighlightedPoint(timestamp, 'm2');
                
                temp1Highlight.push(isM1Point ? '#8b5cf6' : (isM2Point ? '#f59e0b' : null));
                temp2Highlight.push(isM1Point ? '#8b5cf6' : (isM2Point ? '#f59e0b' : null));
                temp3Highlight.push(isM1Point ? '#8b5cf6' : (isM2Point ? '#f59e0b' : null));
            }

            // Completely destroy existing chart and clear canvas
            const canvas = document.getElementById('tempChart');
            if (chart !== null && chart !== undefined) {
                chart.destroy();
                chart = null;
            }
            
            // Clear the canvas
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const datasets = [];
            
            if (kettle1Checked) {
               datasets.push({
    label: 'Kettle 1',
    data: temp1Data,
    borderColor: '#ef4444',
    backgroundColor: 'rgba(239, 68, 68, 0.1)',
    borderWidth: 2,
    tension: 0.4,
    pointRadius: temp1Highlight.map(color => color ? 6 : 2),
    pointBackgroundColor: temp1Highlight.map(color => color || '#ef4444'),
    pointBorderColor: temp1Highlight.map(color => color ? 'white' : '#ef4444'),
    pointBorderWidth: temp1Highlight.map(color => color ? 2 : 0),
    pointHoverRadius: 8,
    spanGaps: true,  // Add this line
    segment: {       // Add this object
        borderColor: ctx => {
            // Make sure line connects through null values
            return ctx.p0.parsed.y !== null && ctx.p1.parsed.y !== null ? 
                   '#ef4444' : 
                   'transparent';
        }
    }
});
            }
            
            if (kettle2Checked) {
                if (kettle2Checked) {
    datasets.push({
        label: 'Kettle 2',
        data: temp2Data,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        borderWidth: 2,
        tension: 0.4,
        pointRadius: temp2Highlight.map(color => color ? 6 : 2),
        pointBackgroundColor: temp2Highlight.map(color => color || '#3b82f6'),
        pointBorderColor: temp2Highlight.map(color => color ? 'white' : '#3b82f6'),
        pointBorderWidth: temp2Highlight.map(color => color ? 2 : 0),
        pointHoverRadius: 8,
        spanGaps: true,  // Add this line
        segment: {       // Add this object
            borderColor: ctx => {
                return ctx.p0.parsed.y !== null && ctx.p1.parsed.y !== null ? 
                       '#3b82f6' : 
                       'transparent';
            }
        }
    });

            }
            
            if (kettle3Checked) {
                if (kettle3Checked) {
    datasets.push({
        label: 'Kettle 3',
        data: temp3Data,
        borderColor: '#10b981',
        backgroundColor: 'rgba(16, 185, 129, 0.1)',
        borderWidth: 2,
        tension: 0.4,
        pointRadius: temp3Highlight.map(color => color ? 6 : 2),
        pointBackgroundColor: temp3Highlight.map(color => color || '#10b981'),
        pointBorderColor: temp3Highlight.map(color => color ? 'white' : '#10b981'),
        pointBorderWidth: temp3Highlight.map(color => color ? 2 : 0),
        pointHoverRadius: 8,
        spanGaps: true,  // Add this line
        segment: {       // Add this object
            borderColor: ctx => {
                return ctx.p0.parsed.y !== null && ctx.p1.parsed.y !== null ? 
                       '#10b981' : 
                       'transparent';
            }
        }
    });
}
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const date = context[0].parsed.x;
                                    return new Date(date).toLocaleString();
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '¬∞C';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                stepSize: 0.5, // 30 minutes
                                displayFormats: {
                                    hour: 'MMM d, HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                maxRotation: 90,
                                minRotation: 90
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Temperature (¬∞C)'
                            },
                            beginAtZero: false,
                            ticks: {
                                stepSize: 5 // 5 degrees apart
                            }
                        }
                    }
                }
            });

            // Add click event for duration measurement
            canvas.onclick = function(event) {
                handleChartClick(event);
            };
        }

        function isHighlightedPoint(timestamp, measurementType) {
            const points = highlightedPoints[measurementType];
            for (let point of points) {
                if (point.timestamp.getTime() === timestamp.getTime()) {
                    return true;
                }
            }
            return false;
        }

        function handleChartClick(event) {
            if (!chart) return;
            
            const canvas = document.getElementById('tempChart');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Convert pixel position to chart value
            const xScale = chart.scales.x;
            const valueX = xScale.getValueForPixel(x);
            
            if (!valueX) return;
            
            // Find the closest data point
            const closestPoint = findClosestDataPoint(valueX);
            
            if (currentMeasurement === 1) {
                // First duration measurement
                if (!isMeasuring1) {
                    // First click - set start point
                    measureStart1 = closestPoint.timestamp;
                    isMeasuring1 = true;
                    document.getElementById('startTimeMeasure1').textContent = new Date(measureStart1).toLocaleString();
                    document.getElementById('endTimeMeasure1').textContent = '--';
                    document.getElementById('durationMeasure1').textContent = '--';
                    
                    // Add to highlighted points
                    highlightedPoints.m1 = [{
                        timestamp: measureStart1,
                        temperature: closestPoint.temperature
                    }];
                } else {
                    // Second click - set end point and calculate duration
                    measureEnd1 = closestPoint.timestamp;
                    isMeasuring1 = false;
                    
                    document.getElementById('endTimeMeasure1').textContent = new Date(measureEnd1).toLocaleString();
                    
                    // Calculate duration
                    const durationMs = Math.abs(measureEnd1 - measureStart1);
                    updateDurationDisplay(durationMs, 'durationMeasure1');
                    
                    // Add to highlighted points
                    highlightedPoints.m1.push({
                        timestamp: measureEnd1,
                        temperature: closestPoint.temperature
                    });
                }
            } else {
                // Second duration measurement
                if (!isMeasuring2) {
                    // First click - set start point
                    measureStart2 = closestPoint.timestamp;
                    isMeasuring2 = true;
                    document.getElementById('startTimeMeasure2').textContent = new Date(measureStart2).toLocaleString();
                    document.getElementById('endTimeMeasure2').textContent = '--';
                    document.getElementById('durationMeasure2').textContent = '--';
                    
                    // Add to highlighted points
                    highlightedPoints.m2 = [{
                        timestamp: measureStart2,
                        temperature: closestPoint.temperature
                    }];
                } else {
                    // Second click - set end point and calculate duration
                    measureEnd2 = closestPoint.timestamp;
                    isMeasuring2 = false;
                    
                    document.getElementById('endTimeMeasure2').textContent = new Date(measureEnd2).toLocaleString();
                    
                    // Calculate duration
                    const durationMs = Math.abs(measureEnd2 - measureStart2);
                    updateDurationDisplay(durationMs, 'durationMeasure2');
                    
                    // Add to highlighted points
                    highlightedPoints.m2.push({
                        timestamp: measureEnd2,
                        temperature: closestPoint.temperature
                    });
                }
            }
            
            // Update the chart to show the new highlighted points
            filterAndDisplayData();
        }

        function findClosestDataPoint(timestamp) {
            // Find the closest data point to the clicked timestamp
            let closestPoint = null;
            let minDiff = Infinity;
            
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            const startDateTime = new Date(startDate + 'T' + startTime);
            const endDateTime = new Date(endDate + 'T' + endTime);
            
            // Get filtered data
            const filteredData = [];
            for (let i = 1; i < allData.length; i++) {
                const rowTimestamp = parseTimestamp(allData[i][0]);
                if (rowTimestamp >= startDateTime && rowTimestamp <= endDateTime) {
                    filteredData.push({
                        timestamp: rowTimestamp,
                        temp1: parseFloat(allData[i][1]) || null,
                        temp2: parseFloat(allData[i][2]) || null,
                        temp3: parseFloat(allData[i][3]) || null
                    });
                }
            }
            
            // Find the closest timestamp
            for (let point of filteredData) {
                const diff = Math.abs(point.timestamp - timestamp);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestPoint = {
                        timestamp: point.timestamp,
                        temperature: point.temp1 || point.temp2 || point.temp3 || 0
                    };
                }
            }
            
            return closestPoint;
        }

        function updateDurationDisplay(durationMs, elementId) {
            const durationMinutes = Math.round(durationMs / (1000 * 60));
            const durationHours = Math.floor(durationMinutes / 60);
            const remainingMinutes = durationMinutes % 60;
            
            let durationText = '';
            if (durationHours > 0) {
                durationText = `${durationHours}h ${remainingMinutes}m`;
            } else {
                durationText = `${durationMinutes}m`;
            }
            
            document.getElementById(elementId).textContent = durationText;
        }

        function parseTimestamp(ts) {
            if (ts instanceof Date) return ts;
            
            // Handle DD/MM/YYYY HH:mm:ss format
            const parts = ts.toString().match(/(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2}):(\d{2})/);
            if (parts) {
                return new Date(parts[3], parts[2] - 1, parts[1], parts[4], parts[5], parts[6]);
            }
            
            return new Date(ts);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function downloadGraph() {
            // Get report data
            const graphTitle = document.getElementById('graphTitle').value || 'RESIN PLANT KETTLE TEMPERATURE MONITORING';
            const kettleNo = document.getElementById('kettleNo').value || '--';
            const resinType = document.getElementById('resinType').value;
            const resinOthers = document.getElementById('resinOthers').value;
            const finalResinType = resinType === 'Others' ? resinOthers : resinType;
            
            const batchNo = document.getElementById('batchNo').value || '--';
            const preparedBy = document.getElementById('preparedBy').value || '--';
            
            const batchQuality = document.getElementById('batchQuality').value;
            const qualityOthers = document.getElementById('qualityOthers').value;
            const finalBatchQuality = batchQuality === 'Others' ? qualityOthers : batchQuality;
            
            const reportComment = document.getElementById('reportComment').value || '';
            
            // Get duration measurements with labels
            const startTimeMeasure1 = document.getElementById('startTimeMeasure1').textContent;
            const endTimeMeasure1 = document.getElementById('endTimeMeasure1').textContent;
            const durationMeasure1 = document.getElementById('durationMeasure1').textContent;
            
            const startTimeMeasure2 = document.getElementById('startTimeMeasure2').textContent;
            const endTimeMeasure2 = document.getElementById('endTimeMeasure2').textContent;
            const durationMeasure2 = document.getElementById('durationMeasure2').textContent;
            
            // Create a temporary canvas to combine chart and report
            const chartCanvas = document.getElementById('tempChart');
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            
            // Calculate dynamic height based on content
            const baseHeight = chartCanvas.height;
            let additionalHeight = 300; // Base space for header and table
            
            // Add space for comments
            if (reportComment) {
                const commentLines = Math.ceil(reportComment.length / 80); // Approximate lines
                additionalHeight += commentLines * 20 + 40;
            }
            
            // Add space for duration measurements
            if (startTimeMeasure1 !== '--' && endTimeMeasure1 !== '--') {
                additionalHeight += 100;
            }
            if (startTimeMeasure2 !== '--' && endTimeMeasure2 !== '--') {
                additionalHeight += 100;
            }
            
            // Set canvas dimensions - dynamic height
            tempCanvas.width = chartCanvas.width;
            tempCanvas.height = baseHeight + additionalHeight;
            
            // Draw white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw report header
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(graphTitle, tempCanvas.width / 2, 30);
            
            // Draw report details in tabular form with proper grid lines
            const tableData = [
                { label: 'Kettle No', value: kettleNo },
                { label: 'Date', value: new Date().toLocaleDateString() },
                { label: 'Resin', value: finalResinType },
                { label: 'Batch No', value: batchNo },
                { label: 'Prepared By', value: preparedBy },
                { label: 'Batch Quality', value: finalBatchQuality }
            ];
            
            // Draw table with proper grid lines
            let yPosition = 70;
            const rowHeight = 35;
            const tableWidth = tempCanvas.width - 100;
            const tableX = 50;
            const labelColWidth = tableWidth * 0.4;
            const valueColWidth = tableWidth * 0.6;
            
            // Draw table headers with background
            ctx.fillStyle = '#f2f2f2';
            ctx.fillRect(tableX, yPosition, tableWidth, rowHeight);
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.strokeRect(tableX, yPosition, tableWidth, rowHeight);
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Parameter', tableX + 10, yPosition + 25);
            ctx.fillText('Value', tableX + labelColWidth + 10, yPosition + 25);
            
            // Draw vertical line between columns
            ctx.beginPath();
            ctx.moveTo(tableX + labelColWidth, yPosition);
            ctx.lineTo(tableX + labelColWidth, yPosition + (rowHeight * (tableData.length + 1)));
            ctx.stroke();
            
            yPosition += rowHeight;
            
            // Draw table rows with alternating background and grid lines
            ctx.font = '18px Arial';
            for (let i = 0; i < tableData.length; i++) {
                const row = tableData[i];
                
                // Alternate row background
                if (i % 2 === 0) {
                    ctx.fillStyle = 'white';
                } else {
                    ctx.fillStyle = '#f9f9f9';
                }
                ctx.fillRect(tableX, yPosition, tableWidth, rowHeight);
                
                // Draw cell borders
                ctx.strokeStyle = '#ddd';
                ctx.strokeRect(tableX, yPosition, tableWidth, rowHeight);
                
                // Draw text
                ctx.fillStyle = 'black';
                ctx.fillText(row.label, tableX + 10, yPosition + 25);
                ctx.fillText(row.value, tableX + labelColWidth + 10, yPosition + 25);
                
                yPosition += rowHeight;
            }
            
            // Draw comment if available
            if (reportComment) {
                yPosition += 30;
                ctx.fillStyle = 'black';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('Comments:', 50, yPosition);
                yPosition += 25;
                ctx.font = '16px Arial';
                
                // Handle multiline comments
                const lines = wrapText(ctx, reportComment, tempCanvas.width - 100, 50, yPosition, 20);
                yPosition += lines * 20;
            }
            
            // Draw duration measurements if available - WITH LABELS
            if (startTimeMeasure1 !== '--' && endTimeMeasure1 !== '--') {
                yPosition += 30;
                ctx.font = 'bold 18px Arial';
                ctx.fillText('Duration Measurement 1:', 50, yPosition);
                yPosition += 25;
                ctx.font = '16px Arial';
                ctx.fillText(`üü£M1 Start: ${startTimeMeasure1}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`üü£M1 End: ${endTimeMeasure1}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`Duration: ${durationMeasure1}`, 50, yPosition);
            }
            
            if (startTimeMeasure2 !== '--' && endTimeMeasure2 !== '--') {
                yPosition += 30;
                ctx.font = 'bold 18px Arial';
                ctx.fillText('Duration Measurement 2:', 50, yPosition);
                yPosition += 25;
                ctx.font = '16px Arial';
                ctx.fillText(`üü†M2 Start: ${startTimeMeasure2}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`üü†M2 End: ${endTimeMeasure2}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`Duration: ${durationMeasure2}`, 50, yPosition);
            }
            
            // Draw the chart - position it with dynamically calculated space
            ctx.drawImage(chartCanvas, 0, yPosition + 20);
            
            // Create download link
            const link = document.createElement('a');
            link.download = `Temperature_Report_${kettleNo}_${finalResinType}_${batchNo}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        function wrapText(ctx, text, maxWidth, x, y, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let lines = 0;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && i > 0) {
                    ctx.fillText(line, x, y);
                    line = words[i] + ' ';
                    y += lineHeight;
                    lines++;
                } else {
                    line = testLine;
                }
            }
            
            ctx.fillText(line, x, y);
            return lines + 1;
        }
    </script>
</body>
</html>
