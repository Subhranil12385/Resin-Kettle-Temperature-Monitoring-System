#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_MAX31865.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <EEPROM.h>

// ===== WiFi credentials =====
const char* ssid = "PlyLab";
const char* password = "sharon123#@";

// ===== Google Apps Script Web App URL =====
const char* googleScriptURL = "https://script.google.com/macros/s/AKfycbzA4T-_Jd-8rfnsFfLSOW9EaTBPJoivWgyDyFav3Y80rIrBubQ8X8oLd3Qi7XK0vKJf/exec";

// ===== DS18B20 data wire pins =====
#define ONE_WIRE_BUS_2 14  // D5
#define ONE_WIRE_BUS_3 12  // D6

// ===== MAX31865 SPI pins =====
#define MAX31865_CS    4   // D2
#define MAX31865_MOSI  13  // D7
#define MAX31865_MISO  0   // D3
#define MAX31865_CLK   2   // D4

// ===== NTP Client for time synchronization =====
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 19800, 60000); // UTC+5:30 = 19800 seconds

// ===== EEPROM settings for offline storage =====
#define EEPROM_SIZE 4096        // Maximum EEPROM size for ESP8266
#define MAX_OFFLINE_READINGS 50 // Maximum number of readings to store offline
#define EEPROM_OFFSET 16        // Reserve first 16 bytes for metadata

// ===== Watchdog and error handling =====
#define WATCHDOG_TIMEOUT 120000     // 2 minutes watchdog timeout
#define MAX_WIFI_CONNECTION_FAILURES 3 // Reboot after 3 failed WiFi connection attempts
#define MAX_GOOGLE_SHEET_ERRORS 2   // Reboot after 2 consecutive Google Sheet errors
unsigned long lastSuccessfulConnection = 0;
int wifiConnectionFailures = 0;
int consecutiveGoogleSheetErrors = 0; // Counter for consecutive Google Sheet errors

// Data structure for offline readings
struct Reading {
  unsigned long epochTime; // Store actual epoch time
  float temp1;
  float temp2;
  float temp3;
  byte checksum; // Simple checksum for data integrity
};

// EEPROM metadata structure
struct StorageMetadata {
  int count;
  int nextIndex;
  unsigned long lastStoredTime;
  byte checksum;
};

// ===== MAX31865 setup =====
Adafruit_MAX31865 max31865 = Adafruit_MAX31865(MAX31865_CS, MAX31865_MOSI, MAX31865_MISO, MAX31865_CLK);

// Use 3-wire RTD (set to 2 or 4 if your PT100 is wired differently)
#define MAX31865_RTD_TYPE MAX31865_3WIRE

// ===== OneWire setup for DS18B20 =====
OneWire oneWire2(ONE_WIRE_BUS_2);
OneWire oneWire3(ONE_WIRE_BUS_3);

DallasTemperature sensor2(&oneWire2);
DallasTemperature sensor3(&oneWire3);

// ===== Timing =====
unsigned long lastLogTime = 0;
const unsigned long logInterval = 50000; // log every 50 sec

// ===== WiFi connection settings =====
const int MAX_WIFI_RETRIES = 10;
const int WIFI_RETRY_DELAY = 1000; // 1 second between retries

// ===== Offline storage variables =====
StorageMetadata storageMeta;
bool wasOffline = false;
bool timeSynced = false;

// Calculate checksum for data integrity
byte calculateChecksum(const void* data, size_t size) {
  byte checksum = 0;
  const byte* bytes = (const byte*)data;
  for (size_t i = 0; i < size; i++) {
    checksum ^= bytes[i];
  }
  return checksum;
}

void setup() {
  Serial.begin(115200);
  Serial.println("PT100 (MAX31865) + DS18B20 Sensors - Google Sheets Logger");
  Serial.println("==========================================================");

  // Initialize watchdog
  lastSuccessfulConnection = millis();

  // Initialize EEPROM
  EEPROM.begin(EEPROM_SIZE);
  
  // Load storage metadata from EEPROM
  loadStorageMetadata();
  
  Serial.print("Offline readings in memory: ");
  Serial.println(storageMeta.count);

  // Start sensors
  sensor2.begin();
  sensor3.begin();

  // Initialize MAX31865
  if (!max31865.begin(MAX31865_RTD_TYPE)) {
    Serial.println("MAX31865 not found. Check wiring!");
    delay(1000);
    // Don't reboot immediately for sensor issues
  }

  // Connect WiFi with retry mechanism
  if (!connectWiFiWithRetry()) {
    Serial.println("WiFi connection failed. Will work offline.");
    wasOffline = true;
    wifiConnectionFailures++;
  } else {
    wifiConnectionFailures = 0; // Reset on successful connection
  }
  
  // Initialize NTP client
  timeClient.begin();
  
  // Update successful connection timestamp
  lastSuccessfulConnection = millis();
}

void loadStorageMetadata() {
  EEPROM.get(0, storageMeta);
  
  // Validate metadata with checksum
  byte storedChecksum = storageMeta.checksum;
  storageMeta.checksum = 0; // Reset before calculation
  byte calculatedChecksum = calculateChecksum(&storageMeta, sizeof(storageMeta) - 1);
  
  if (storedChecksum != calculatedChecksum || 
      storageMeta.count > MAX_OFFLINE_READINGS || 
      storageMeta.count < 0) {
    // Metadata is corrupted, reset it
    Serial.println("EEPROM metadata corrupted, resetting...");
    storageMeta.count = 0;
    storageMeta.nextIndex = 0;
    storageMeta.lastStoredTime = 0;
    saveStorageMetadata();
  }
}

void saveStorageMetadata() {
  // Calculate checksum before saving
  storageMeta.checksum = 0; // Reset before calculation
  storageMeta.checksum = calculateChecksum(&storageMeta, sizeof(storageMeta) - 1);
  
  EEPROM.put(0, storageMeta);
  EEPROM.commit();
}

bool connectWiFiWithRetry() {
  int retryCount = 0;
  
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  
  while (WiFi.status() != WL_CONNECTED && retryCount < MAX_WIFI_RETRIES) {
    delay(WIFI_RETRY_DELAY);
    Serial.print(".");
    retryCount++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected!");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
    
    // Update time from NTP server
    if (updateTimeFromNTP()) {
      timeSynced = true;
    }
    
    // If we were offline and have stored readings, send them
    if (storageMeta.count > 0) {
      sendOfflineReadings();
    }
    
    return true;
  } else {
    Serial.println("\nFailed to connect to WiFi. Working offline...");
    wasOffline = true;
    return false;
  }
}

bool updateTimeFromNTP() {
  Serial.print("Updating time from NTP server...");
  for (int i = 0; i < 5; i++) { // Try up to 5 times
    if (timeClient.update()) {
      Serial.println(" Success!");
      Serial.print("Current time: ");
      Serial.println(timeClient.getFormattedTime());
      return true;
    }
    delay(1000);
  }
  Serial.println(" Failed!");
  return false;
}

void checkWiFiConnection() {
  static unsigned long lastCheck = 0;
  const unsigned long checkInterval = 30000; // Check every 30 seconds
  
  if (millis() - lastCheck >= checkInterval) {
    lastCheck = millis();
    
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi connection lost. Working offline...");
      wasOffline = true;
      
      // Try to reconnect
      WiFi.disconnect();
      delay(1000);
      if (!WiFi.begin(ssid, password)) {
        wifiConnectionFailures++;
      }
    } else if (wasOffline) {
      Serial.println("WiFi reconnected!");
      wasOffline = false;
      wifiConnectionFailures = 0; // Reset on successful reconnection
      lastSuccessfulConnection = millis();
      
      // Update time when reconnected
      if (updateTimeFromNTP()) {
        timeSynced = true;
      }
      
      // Send any offline readings we have stored
      if (storageMeta.count > 0) {
        sendOfflineReadings();
      }
    }
  }
}

unsigned long getCurrentEpochTime() {
  if (timeSynced) {
    return timeClient.getEpochTime();
  } else {
    // Fallback: use millis() to estimate time if NTP not available
    return (millis() / 1000) + storageMeta.lastStoredTime;
  }
}

bool storeReading(float temp1, float temp2, float temp3) {
  if (storageMeta.count >= MAX_OFFLINE_READINGS) {
    Serial.println("Offline storage full! Overwriting oldest reading.");
    
    // We're at capacity, don't store more
    return false;
  }
  
  // Create the new reading
  Reading newReading;
  newReading.epochTime = getCurrentEpochTime();
  newReading.temp1 = temp1;
  newReading.temp2 = temp2;
  newReading.temp3 = temp3;
  newReading.checksum = 0; // Reset before calculation
  newReading.checksum = calculateChecksum(&newReading, sizeof(newReading) - 1);
  
  // Calculate storage address
  int address = EEPROM_OFFSET + (storageMeta.nextIndex * sizeof(Reading));
  
  // Store the reading
  EEPROM.put(address, newReading);
  
  // Update metadata
  storageMeta.count++;
  storageMeta.nextIndex = (storageMeta.nextIndex + 1) % MAX_OFFLINE_READINGS;
  storageMeta.lastStoredTime = millis() / 1000;
  
  // Save updated metadata
  saveStorageMetadata();
  EEPROM.commit();
  
  Serial.print("Stored offline reading. Total: ");
  Serial.println(storageMeta.count);
  
  return true;
}

void sendOfflineReadings() {
  if (storageMeta.count == 0) {
    Serial.println("No offline readings to send.");
    return;
  }
  
  Serial.print("Sending ");
  Serial.print(storageMeta.count);
  Serial.println(" offline readings...");
  
  int sentCount = 0;
  int failedCount = 0;
  
  // Read through all stored readings
  for (int i = 0; i < storageMeta.count; i++) {
    // Calculate the actual index (circular buffer)
    int index = (storageMeta.nextIndex - storageMeta.count + i + MAX_OFFLINE_READINGS) % MAX_OFFLINE_READINGS;
    int address = EEPROM_OFFSET + (index * sizeof(Reading));
    
    // Read the reading
    Reading reading;
    EEPROM.get(address, reading);
    
    // Validate checksum
    byte storedChecksum = reading.checksum;
    reading.checksum = 0; // Reset before calculation
    byte calculatedChecksum = calculateChecksum(&reading, sizeof(reading) - 1);
    
    if (storedChecksum != calculatedChecksum) {
      Serial.println("Corrupted reading found, skipping...");
      failedCount++;
      continue;
    }
    
    // Try to send the reading
    if (logToGoogleSheets(reading.temp1, reading.temp2, reading.temp3, true, reading.epochTime)) {
      Serial.print("Sent offline reading ");
      Serial.print(i + 1);
      Serial.print(" of ");
      Serial.println(storageMeta.count);
      
      // Update successful connection timestamp
      lastSuccessfulConnection = millis();
      consecutiveGoogleSheetErrors = 0; // Reset Google Sheet error counter on success
      sentCount++;
      
      // Small delay between sends to avoid overwhelming the server
      delay(100);
    } else {
      Serial.println("Failed to send offline reading. Stopping.");
      consecutiveGoogleSheetErrors++; // Increment Google Sheet error counter
      failedCount++;
      break;
    }
  }
  
  // If all readings were sent successfully, clear the storage
  if (sentCount == storageMeta.count) {
    storageMeta.count = 0;
    storageMeta.nextIndex = 0;
    saveStorageMetadata();
    EEPROM.commit();
    
    Serial.println("All offline readings sent and cleared.");
  } else if (failedCount > 0) {
    // If some failed, keep only the failed ones
    storageMeta.count = failedCount;
    storageMeta.nextIndex = (storageMeta.nextIndex - sentCount + MAX_OFFLINE_READINGS) % MAX_OFFLINE_READINGS;
    saveStorageMetadata();
    EEPROM.commit();
    
    Serial.print("Partial success. ");
    Serial.print(sentCount);
    Serial.print(" sent, ");
    Serial.print(failedCount);
    Serial.println(" remaining.");
  }
}

void checkWatchdog() {
  // Check if we've had too many consecutive Google Sheet errors
  if (consecutiveGoogleSheetErrors >= MAX_GOOGLE_SHEET_ERRORS) {
    Serial.println("Too many consecutive Google Sheet errors. Rebooting...");
    delay(1000);
    ESP.restart();
  }
  
  // Check if we've had too many WiFi connection failures
  if (wifiConnectionFailures >= MAX_WIFI_CONNECTION_FAILURES) {
    Serial.println("Too many WiFi connection failures. Rebooting...");
    delay(1000);
    ESP.restart();
  }
  
  // Check if it's been too long since a successful connection
  if (millis() - lastSuccessfulConnection > WATCHDOG_TIMEOUT) {
    Serial.println("Watchdog timeout. No successful connection in too long. Rebooting...");
    delay(1000);
    ESP.restart();
  }
}

void loop() {
  // Check watchdog timer
  checkWatchdog();
  
  // Check WiFi connection status
  checkWiFiConnection();
  
  // Update NTP time periodically if connected
  if (WiFi.status() == WL_CONNECTED) {
    timeClient.update();
  }
  
  // Read PT100 (MAX31865)
  uint16_t rtd = max31865.readRTD();
  float ratio = rtd;
  ratio /= 32768;
  float temp1 = max31865.temperature(100.0, 430.0); // PT100 = 100Ω at 0°C, Rref=430Ω

  // Read DS18B20s
  sensor2.requestTemperatures();
  sensor3.requestTemperatures();
  float temp2 = sensor2.getTempCByIndex(0);
  float temp3 = sensor3.getTempCByIndex(0);

  // Serial output
  Serial.println("Temperature Readings:");
  Serial.println("---------------------");

  Serial.print("PT100 (MAX31865): ");
  if (!isnan(temp1)) {
    Serial.print(temp1);
    Serial.println(" °C");
  } else {
    Serial.println("Error");
    temp1 = -999;
  }

  Serial.print("Sensor 2 (DS18B20 D5): ");
  if (temp2 != DEVICE_DISCONNECTED_C) {
    Serial.print(temp2);
    Serial.println(" °C");
  } else {
    Serial.println("Error: Disconnected");
    temp2 = -999;
  }

  Serial.print("Sensor 3 (DS18B20 D6): ");
  if (temp3 != DEVICE_DISCONNECTED_C) {
    Serial.print(temp3);
    Serial.println(" °C");
  } else {
    Serial.println("Error: Disconnected");
    temp3 = -999;
  }

  // Log to Google Sheets every interval or store offline if disconnected
  if (millis() - lastLogTime >= logInterval) {
    if (WiFi.status() == WL_CONNECTED) {
      if (logToGoogleSheets(temp1, temp2, temp3, false, getCurrentEpochTime())) {
        lastLogTime = millis();
        // Update successful connection timestamp
        lastSuccessfulConnection = millis();
        consecutiveGoogleSheetErrors = 0; // Reset Google Sheet error counter on success
      } else {
        // Logging failed, store offline
        Serial.println("Online logging failed, storing offline...");
        consecutiveGoogleSheetErrors++; // Increment Google Sheet error counter
        
        if (storeReading(temp1, temp2, temp3)) {
          lastLogTime = millis();
        }
      }
    } else {
      // Store reading offline
      Serial.println("Offline mode, storing reading...");
      if (storeReading(temp1, temp2, temp3)) {
        lastLogTime = millis();
      }
    }
  }

  Serial.println();
  delay(5000);
}

bool logToGoogleSheets(float temp1, float temp2, float temp3, bool isOffline, unsigned long epochTime) {
  WiFiClientSecure client;
  client.setInsecure();
  client.setTimeout(10000); // 10 second timeout

  HTTPClient http;
  if (!http.begin(client, googleScriptURL)) {
    Serial.println("HTTP begin failed");
    return false;
  }
  
  http.addHeader("Content-Type", "application/x-www-form-urlencoded");
  http.setTimeout(10000); // 10 second timeout

  String postData = "temp1=" + String(temp1, 2) +
                   "&temp2=" + String(temp2, 2) +
                   "&temp3=" + String(temp3, 2) +
                   "&offline=" + String(isOffline ? "1" : "0");
  
  // Add epoch time for offline data (0 means use current time on server)
  if (isOffline && epochTime > 0) {
    postData += "&epochTime=" + String(epochTime);
  }

  Serial.print("Logging to Google Sheets... ");
  int httpResponseCode = http.POST(postData);

  if (httpResponseCode > 0) {
    String response = http.getString();
    Serial.println("Success!");
    Serial.println("Response: " + response);
    http.end();
    return true;
  } else {
    Serial.print("Error: ");
    Serial.println(httpResponseCode);
    http.end();
    return false;
  }
}
