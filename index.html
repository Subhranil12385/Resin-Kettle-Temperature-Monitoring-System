<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resin Kettle Temperature Monitoring Dashboard - CPIL Chennai</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/3.0.1/luxon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-luxon/1.1.0/chartjs-adapter-luxon.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .status-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            padding: 12px 25px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-badge.online {
            background: #10b981;
            color: white;
        }

        .status-badge.offline {
            background: #ef4444;
            color: white;
        }

        .status-badge::before {
            content: '';
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .last-update {
            color: #666;
            font-size: 0.9em;
        }

        .current-temps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .temp-box {
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .temp-box h3 {
            font-size: 0.9em;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .temp-box .value {
            font-size: 2em;
            font-weight: bold;
        }

        .controls-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .controls-card h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .date-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        .control-group input,
        .control-group select {
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-secondary.active {
            background: #667eea;
            color: white;
        }

        .chart-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .chart-card h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 400px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: #f9fafb;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-item .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-item .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .kettle-selection {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .kettle-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f3f4f6;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .kettle-checkbox:hover {
            background: #e5e7eb;
        }

        .kettle-checkbox input {
            margin: 0;
        }

        .duration-measurement {
            background: #f9fafb;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .duration-measurement h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .duration-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .duration-instruction {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .duration-result {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .duration-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 150px;
        }

        .duration-item .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .duration-item .value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }

        .report-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .report-section h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .report-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-group label {
            font-weight: 600;
            color: #555;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Enhanced Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            animation: fadeIn 0.5s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .loading-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .loading-title {
            color: white;
            font-size: 2em;
            margin-bottom: 30px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .loading-quote-container {
            min-height: 120px;
            margin-bottom: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .loading-quote {
            font-size: 1.4em;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-left: 4px solid;
            position: absolute;
            width: 100%;
        }

        /* New smooth transition animations */
        @keyframes quoteFadeOutUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }

        @keyframes quoteFadeInDown {
            0% {
                opacity: 0;
                transform: translateY(30px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .loading-icons-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .loading-icon {
            width: 60px;
            height: 60px;
            position: relative;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1.5s linear infinite;
        }

        .dots {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            gap: 8px;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .line {
            width: 60px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .line::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 30%;
            background: white;
            animation: lineMove 2s infinite ease-in-out;
        }

        @keyframes lineMove {
            0% { left: -30%; }
            100% { left: 130%; }
        }

        .hourglass {
            width: 40px;
            height: 50px;
            position: relative;
            margin: 0 auto;
        }

        .hourglass::before,
        .hourglass::after {
            content: '';
            position: absolute;
            left: 0;
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
        }

        .hourglass::before {
            top: 0;
            border-top: 25px solid white;
            animation: topSand 3s infinite;
        }

        .hourglass::after {
            bottom: 0;
            border-bottom: 25px solid white;
            animation: bottomSand 3s infinite;
        }

        @keyframes topSand {
            0%, 50% { border-top-color: white; }
            51%, 100% { border-top-color: rgba(255, 255, 255, 0.3); }
        }

        @keyframes bottomSand {
            0%, 50% { border-bottom-color: rgba(255, 255, 255, 0.3); }
            51%, 100% { border-bottom-color: white; }
        }

        .loading-progress {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 20px;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .loading-status {
            color: rgba(255, 255, 255, 0.8);
            margin-top: 15px;
            font-size: 0.9em;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .temp-high-low {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .temp-high-low .high {
            color: #3b82f6;
            font-weight: bold;
        }

        .temp-high-low .low {
            color: #3b82f6;
            font-weight: bold;
        }
        
        .auto-refresh-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .auto-refresh-control label {
            font-weight: 600;
            color: #555;
        }
        
        .others-input {
            margin-top: 8px;
            display: none;
        }
        
        .others-input.show {
            display: block;
        }
        
        .dual-duration-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .measurement-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }
        
        @media (max-width: 768px) {
            .dual-duration-container {
                grid-template-columns: 1fr;
            }
        }
        
        .comment-section {
            margin-top: 20px;
        }
        
        .comment-section textarea {
            width: 100%;
            min-height: 100px;
            resize: vertical;
        }
        
        .measurement-legend {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        .legend-color.m1 {
            background-color: #8b5cf6;
        }
        
        .legend-color.m2 {
            background-color: #f59e0b;
        }
        
        .data-filtering-controls {
            background: #f9fafb;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .data-filtering-controls h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .filter-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filter-info {
            margin-top: 15px;
            padding: 10px;
            background: #e5e7eb;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .filter-info .removed-count {
            color: #ef4444;
            font-weight: bold;
        }




















.quick-buttons-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.quick-btn {
    padding: 6px 12px;
    border: 1px solid #667eea;
    border-radius: 4px;
    background: #f8fafc;
    color: #667eea;
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.quick-btn:hover {
    background: #667eea;
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
}

.quick-btn:active {
    transform: translateY(0);
}

@media (max-width: 768px) {
    .quick-buttons-group {
        gap: 5px;
    }
    
    .quick-btn {
        padding: 5px 8px;
        font-size: 0.8em;
    }
}















/* Link Toggle Styles */
.link-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 8px 0;
    padding: 5px 10px;
    background: #f1f5f9;
    border-radius: 20px;
    width: fit-content;
    font-size: 0.85em;
}

.link-toggle input[type="checkbox"] {
    margin: 0;
    width: 16px;
    height: 16px;
    cursor: pointer;
}

.link-toggle label {
    cursor: pointer;
    color: #475569;
    font-weight: 500;
    user-select: none;
}

.link-toggle input[type="checkbox"]:checked {
    accent-color: #10b981;
}


























    </style>
</head>
<body>
    <!-- Enhanced Loading Overlay -->
    <div id="enhancedLoadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="loading-title">Resin Kettle Dashboard</div>
            
            <div class="loading-quote-container">
                <div id="loadingQuote" class="loading-quote"></div>
            </div>
            
            <div class="loading-icons-container">
                <div class="loading-icon">
                    <div class="spinner"></div>
                </div>
                <div class="loading-icon">
                    <div class="dots">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </div>
                <div class="loading-icon">
                    <div class="line"></div>
                </div>
                <div class="loading-icon">
                    <div class="hourglass"></div>
                </div>
            </div>
            
            <div class="loading-progress">
                <div id="loadingProgressBar" class="loading-progress-bar"></div>
            </div>
            
            <div id="loadingStatus" class="loading-status">Initializing dashboard...</div>
        </div>
    </div>

    <!-- Main Dashboard Content -->
    <div class="container">
        <div class="header">
            <h1>üå°Ô∏èResin Kettle Temperature Monitoring Dashboard - CPIL Chennai</h1>
            <p>Real-time monitoring and historical data visualization</p>
        </div>

        <div class="status-card">
            <div class="status-header">
                <div class="status-indicator">
                    <div id="statusBadge" class="status-badge online">
                        <span id="statusText">ONLINE</span>
                    </div>
                </div>
                <div class="last-update">
                    Last Update: <strong id="lastUpdate">--</strong>
                </div>
            </div>

            <div class="current-temps">
                <div class="temp-box" id="tempBox1">
                    <h3>Kettle 1</h3>
                    <div class="value" id="temp1">--¬∞C</div>
                    <div class="temp-high-low">
                        <span class="low" id="lowTemp1">--¬∞C</span>
                        <span class="high" id="highTemp1">--¬∞C</span>
                    </div>
                </div>
                <div class="temp-box" id="tempBox2">
                    <h3>Kettle 2</h3>
                    <div class="value" id="temp2">--¬∞C</div>
                    <div class="temp-high-low">
                        <span class="low" id="lowTemp2">--¬∞C</span>
                        <span class="high" id="highTemp2">--¬∞C</span>
                    </div>
                </div>
                <div class="temp-box" id="tempBox3">
                    <h3>Kettle 3</h3>
                    <div class="value" id="temp3">--¬∞C</div>
                    <div class="temp-high-low">
                        <span class="low" id="lowTemp3">--¬∞C</span>
                        <span class="high" id="highTemp3">--¬∞C</span>
                    </div>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="label">Time Range</div>
                    <div class="value" id="timeRange">--</div>
                </div>
            </div>
        </div>

        <div class="controls-card">
            <h2>üìÖ Date and Time Selection</h2>
            <div class="date-controls">
                <div class="control-group">
                    <label for="startDate">Start Date</label>
                    <input type="date" id="startDate">
                </div>
                <div class="control-group">
                    <label for="startTime">Start Time</label>
                    <input type="time" id="startTime" value="00:00">
                </div>
                <div class="control-group">
                    <label for="endDate">End Date</label>
                    <input type="date" id="endDate">
                </div>
                <div class="control-group">
                    <label for="endTime">End Time</label>
                    <input type="time" id="endTime" value="23:59">
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="loadData()">üìä Load Data</button>
                <button class="btn-secondary active" id="todayBtn" onclick="setToday()">Today</button>
                <button class="btn-secondary" id="last24Btn" onclick="setLast24Hours()">Last 24 Hours</button>
                <button class="btn-secondary" id="last3DaysBtn" onclick="setLast3Days()">Last 3 Days</button>
                <button class="btn-secondary" id="thisWeekBtn" onclick="setThisWeek()">This Week</button>
            </div>
            <div class="auto-refresh-control">
                <label for="autoRefresh">Auto Refresh:</label>
                <input type="checkbox" id="autoRefresh" onchange="toggleAutoRefresh()">
                <label for="autoRefresh">Enabled</label>
            </div>
        </div>

        <div id="errorMessage" class="error" style="display: none;"></div>

        <div class="chart-card">
            <h2>üìà Temperature Trends</h2>
            
            <div class="kettle-selection">
                <label class="kettle-checkbox">
                    <input type="checkbox" id="kettle1Check" checked>
                    Kettle 1
                </label>
                <label class="kettle-checkbox">
                    <input type="checkbox" id="kettle2Check" checked>
                    Kettle 2
                </label>
                <label class="kettle-checkbox">
                    <input type="checkbox" id="kettle3Check" checked>
                    Kettle 3
                </label>
            </div>
            
            <div class="measurement-buttons">
                <button class="btn-primary" id="measureBtn1" onclick="setActiveMeasurement(1)">Measure Duration 1</button>
                <button class="btn-secondary" id="measureBtn2" onclick="setActiveMeasurement(2)">Measure Duration 2</button>
            </div>
            
            <div class="measurement-legend">
                <div class="legend-item">
                    <div class="legend-color m1"></div>
                    <span>Measurement 1 Points</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color m2"></div>
                    <span>Measurement 2 Points</span>
                </div>
            </div>
            
            <div class="chart-container">
                <canvas id="tempChart"></canvas>
            </div>
            
            <div class="data-filtering-controls">
                <h3>üîß Data Filtering Options</h3>
                <div class="filter-controls">
                    <div class="control-group">
                        <label for="spikeThreshold">Spike/Fall Detection Threshold</label>
                        <input type="number" id="spikeThreshold" value="0.1" min="0.0001" max="50" step="0.01">
                    </div>
                    <div class="control-group">
                        <label for="enableFiltering">Enable Spike/Fall Filtering</label>
                        <input type="checkbox" id="enableFiltering" checked>
                    </div>
                    <button class="btn-secondary" onclick="filterAndDisplayData()">Apply Filter</button>
                </div>
                <div class="filter-info">
                    <p>Spike/fall filtering removes noisy reading. Set to 0 for even smoother graph</p>
                    <p>Removed data points: <span class="removed-count" id="removedCount">0</span></p>
                </div>
            </div>
            
            <div class="dual-duration-container">
                <div class="duration-measurement">
                    <h3>‚è±Ô∏è Duration Measurement 1</h3>
                    <div class="duration-instruction">
                        Click on the chart to select two points to measure the time duration between them.
                    </div>
                    <div class="duration-result">
                        <div class="duration-item">
                            <div class="label">Start Time</div>
                            <div class="value" id="startTimeMeasure1">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">End Time</div>
                            <div class="value" id="endTimeMeasure1">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">Duration</div>
                            <div class="value" id="durationMeasure1">--</div>
                        </div>
                    </div>
                </div>
                
                <div class="duration-measurement">
                    <h3>‚è±Ô∏è Click Duration Measurement 2</h3>
                    <div class="duration-instruction">
                        Click on the chart to select two points and measure the time duration between them.
                    </div>
                    <div class="duration-result">
                        <div class="duration-item">
                            <div class="label">Start Time</div>
                            <div class="value" id="startTimeMeasure2">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">End Time</div>
                            <div class="value" id="endTimeMeasure2">--</div>
                        </div>
                        <div class="duration-item">
                            <div class="label">Duration</div>
                            <div class="value" id="durationMeasure2">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="report-section">
            <h2>üìã Report Generation</h2>
            <div class="report-form">





<div class="form-group">
    <label for="graphTitle">Graph Title</label>
    <input type="text" id="graphTitle" placeholder="e.g., Kettle 1 Temperature Analysis">
    
    <!-- Link Toggle -->
    <div class="link-toggle">
        <input type="checkbox" id="linkToggle" checked>
        <label for="linkToggle">Link with Resin Type</label>
    </div>
    
    <!-- Graph Title Quick Buttons -->
    <div class="quick-buttons-group">
        <button type="button" class="quick-btn" onclick="handleGraphTitleClick('CPIL - 03 / PF')">CPIL - 03 / PF</button>
        <button type="button" class="quick-btn" onclick="handleGraphTitleClick('CPIL - 03 / UF')">CPIL - 03 / UF</button>
        <button type="button" class="quick-btn" onclick="handleGraphTitleClick('CPIL - 03 / MF')">CPIL - 03 / MF</button>
        <button type="button" class="quick-btn" onclick="handleGraphTitleClick('CPIL - 03 / UMF')">CPIL - 03 / UMF</button>
    </div>
</div>





                <div class="form-group">
                    <label for="kettleNo">Kettle No</label>
                    <select id="kettleNo" onchange="handleKettleNoChange()">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                </div>





<div class="form-group">
    <label for="resinType">Resin</label>
    <select id="resinType" onchange="handleResinTypeChange()">
        <option value="MF">MF</option>
        <option value="PF">PF</option>
        <option value="UF">UF</option>
        <option value="UMF">UMF</option>
        <option value="Others">Others, Please specify</option>
    </select>
    <input type="text" id="resinOthers" class="others-input" placeholder="Specify resin type">
</div>










                <div class="form-group">
                    <label for="batchNo">Batch No.</label>
                    <input type="text" id="batchNo" placeholder="e.g., 36">
                </div>






<div class="form-group">
    <label for="preparedBy">Prepared By</label>
    <input type="text" id="preparedBy" placeholder="e.g., Mr. XYZ">
    
    <!-- Prepared By Quick Buttons -->
    <div class="quick-buttons-group">
        <button type="button" class="quick-btn" onclick="setPreparedBy('MR. KARLUS SURIN')">MR. KARLUS SURIN</button>
        <button type="button" class="quick-btn" onclick="setPreparedBy('MR. ROMAN')">MR. ROMAN</button>
        <button type="button" class="quick-btn" onclick="setPreparedBy('MR. DAMODHAR')">MR. DAMODHAR</button>
    </div>
</div>
                <div class="form-group">
                    <label for="batchQuality">Batch Quality</label>
                    <select id="batchQuality" onchange="toggleOthersInput('qualityOthers')">
                        <option value="OK">OK</option>
                        <option value="NOT OK">NOT OK</option>
                        <option value="Others">Others, Please specify</option>
                    </select>
                    <input type="text" id="qualityOthers" class="others-input" placeholder="Specify quality">
                </div>
            </div>
            
            <div class="comment-section">
                <div class="form-group">
                    <label for="reportComment">Additional Comments (Optional)</label>
                    <textarea id="reportComment" placeholder="Add any additional comments here..."></textarea>
                </div>
            </div>
            
            <button class="btn-primary" onclick="downloadGraph()">üì• Download Graph with Report</button>
        </div>
    </div>

    <script>
        const SHEET_URL = 'https://script.google.com/macros/s/AKfycbw1Yj4Ct-2BR1mrk-FZ5Il7LxMHMJ8KNk4RE1F_ryJuVQ1ZIK3JaL5sqP9Zbi_hiWHb/exec';
        let chart = null;
        let allData = [];
        let filteredData = [];
        let isMeasuring1 = false;
        let isMeasuring2 = false;
        let measureStart1 = null;
        let measureEnd1 = null;
        let measureStart2 = null;
        let measureEnd2 = null;
        let autoRefreshInterval = null;
        let isFirstLoad = true;
        let currentMeasurement = 1; // 1 or 2 for which duration measurement is active
        let highlightedPoints = {
            m1: [],
            m2: []
        };
        let removedSpikesCount = 0;
        let loadingInterval = null;
        let quoteIndex = 0;
        let loadingProgress = 0;
let isLinkingEnabled = true;

// Function to handle Graph Title button clicks
function handleGraphTitleClick(title) {
    // Set the graph title
    document.getElementById('graphTitle').value = title;
    
    // If linking is enabled, also update the Resin Type dropdown
    if (isLinkingEnabled) {
        // Extract resin type from title (e.g., "CPIL - 03 / PF" -> "PF")
        const parts = title.split('/');
        const resinType = parts[parts.length - 1].trim();
        const resinTypeSelect = document.getElementById('resinType');
        
        // Set the resin type dropdown
        for (let i = 0; i < resinTypeSelect.options.length; i++) {
            if (resinTypeSelect.options[i].value === resinType) {
                resinTypeSelect.selectedIndex = i;
                break;
            }
        }
        
        // ALSO UPDATE KETTLE NO BASED ON RESIN TYPE
        updateKettleNoFromResinType(resinType);
        
        // Trigger the change event to update others input
        resinTypeSelect.dispatchEvent(new Event('change'));
    }
}

// Function to handle Resin Type dropdown changes
function handleResinTypeChange() {
    const resinTypeSelect = document.getElementById('resinType');
    const selectedResin = resinTypeSelect.value;
    
    // Always handle Others input visibility
    toggleOthersInput('resinOthers');
    
    // If linking is enabled and not "Others", update the Graph Title
    if (isLinkingEnabled && selectedResin !== 'Others') {
        const graphTitle = `CPIL - 03 / ${selectedResin}`;
        document.getElementById('graphTitle').value = graphTitle;
        
        // ALSO UPDATE KETTLE NO BASED ON RESIN TYPE
        updateKettleNoFromResinType(selectedResin);
    }
    
    // If "Others" is selected and linking is enabled, clear graph title
    if (isLinkingEnabled && selectedResin === 'Others') {
        document.getElementById('graphTitle').value = '';
        // Don't change kettle no for "Others"
    }
}

// Function to update Kettle No based on Resin Type
function updateKettleNoFromResinType(resinType) {
    const kettleNoSelect = document.getElementById('kettleNo');
    
    if (resinType === 'PF') {
        // PF -> Kettle 1
        kettleNoSelect.value = '1';
    } else if (resinType === 'UF' || resinType === 'MF' || resinType === 'UMF') {
        // UF/MF/UMF -> Kettle 3
        kettleNoSelect.value = '3';
    }
    // For Kettle 2 - no automatic change (keep as is)
    // For "Others" - no automatic change
}

// Function to handle Kettle No changes
function handleKettleNoChange() {
    if (!isLinkingEnabled) return;
    
    const kettleNo = document.getElementById('kettleNo').value;
    const resinTypeSelect = document.getElementById('resinType');
    const currentResin = resinTypeSelect.value;
    
    // Only suggest changes, don't force them
    if (kettleNo === '1' && currentResin !== 'PF') {
        // If user selects Kettle 1, suggest PF
        console.log("Kettle 1 is typically used for PF resin");
        // Optional: You could show a tooltip or hint here
    } else if (kettleNo === '3' && !['UF', 'MF', 'UMF'].includes(currentResin)) {
        // If user selects Kettle 3, suggest UF/MF/UMF
        console.log("Kettle 3 is typically used for UF, MF, or UMF resin");
        // Optional: You could show a tooltip or hint here
    }
}

// Function to update the toggle state
function updateLinkToggle() {
    const toggle = document.getElementById('linkToggle');
    isLinkingEnabled = toggle.checked;
    
    // Visual feedback
    const label = toggle.nextElementSibling;
    if (isLinkingEnabled) {
        label.innerHTML = '<span style="color:#10b981">‚úì</span> Link with Resin Type & Kettle No';
    } else {
        label.innerHTML = '<span style="color:#ef4444">‚úó</span> Link with Resin Type & Kettle No';
    }
}














// Keep the original toggleOthersInput function but update it
function toggleOthersInput(inputId) {
    const resinSelect = document.getElementById('resinType');
    const qualitySelect = document.getElementById('batchQuality');
    const resinOthers = document.getElementById('resinOthers');
    const qualityOthers = document.getElementById('qualityOthers');
    
    // Show/hide resin others input
    if (resinSelect.value === 'Others') {
        resinOthers.classList.add('show');
    } else {
        resinOthers.classList.remove('show');
        resinOthers.value = ''; // Clear the value when not showing
    }
    
    // Show/hide quality others input
    if (qualitySelect.value === 'Others') {
        qualityOthers.classList.add('show');
    } else {
        qualityOthers.classList.remove('show');
        qualityOthers.value = ''; // Clear the value when not showing
    }
}

// Keep the original setPreparedBy function
function setPreparedBy(name) {
    document.getElementById('preparedBy').value = name;
}
        // Random quotes with RGB colors
        const loadingQuotes = [
            { text: "Temperature is the silent language of processes", color: "rgb(102, 126, 234)" },
            { text: "Precision monitoring ensures quality production", color: "rgb(239, 68, 68)" },
            { text: "Data is the new oil, insights are the refined fuel", color: "rgb(16, 185, 129)" },
            { text: "Every degree tells a story of chemical transformation", color: "rgb(245, 158, 11)" },
            { text: "Real-time analytics drive operational excellence", color: "rgb(139, 92, 246)" },
            { text: "The perfect batch starts with perfect monitoring", color: "rgb(59, 130, 246)" },
            { text: "From raw data to actionable intelligence", color: "rgb(236, 72, 153)" },
            { text: "Consistency is the hallmark of industrial excellence", color: "rgb(20, 184, 166)" },
            { text: "Temperature control is the backbone of industrial reliability", color: "rgb(218, 85, 67)" },
            { text: "Automation turns consistency into a habit", color: "rgb(34, 151, 210)" },
            { text: "Smart factories don't guess ‚Äî they measure", color: "rgb(131, 204, 70)" },
            { text: "Behind every great product lies precise monitoring", color: "rgb(255, 142, 55)" },
            { text: "Accuracy today prevents downtime tomorrow", color: "rgb(90, 82, 219)" },
            { text: "Vibration speaks louder than failure ‚Äî if you listen", color: "rgb(230, 60, 108)" },
            { text: "When data flows smoothly, production does too", color: "rgb(51, 187, 165)" },
            { text: "Efficiency is engineered, not imagined", color: "rgb(176, 112, 255)" },
            { text: "Calibration builds confidence in every measurement", color: "rgb(236, 96, 32)" },
            { text: "Automation is the art of eliminating unpredictability", color: "rgb(53, 198, 242)" },
            { text: "Industrial intelligence begins at the sensor", color: "rgb(123, 189, 78)" },
            { text: "A controlled environment is the home of quality", color: "rgb(255, 175, 80)" },
            { text: "Downtime is expensive ‚Äî monitoring is cheap", color: "rgb(101, 87, 234)" },
            { text: "Sensors don't lie ‚Äî they warn", color: "rgb(245, 76, 122)" },
            { text: "Process optimization is a journey powered by data", color: "rgb(25, 183, 162)" },
            { text: "Innovation begins where measurements improve", color: "rgb(178, 120, 251)" },
            { text: "Industrial health is measured in degrees and hertz", color: "rgb(255, 93, 52)" },
            { text: "Insight is the real outcome of monitoring", color: "rgb(64, 175, 232)" },
            { text: "We don't just track data ‚Äî we understand behavior", color: "rgb(120, 208, 65)" },
            { text: "Every stable temperature protects the product", color: "rgb(254, 153, 48)" },
            { text: "Consistency is the bridge between reliability and trust", color: "rgb(85, 77, 222)" },
            { text: "Predictive maintenance starts with attention to detail", color: "rgb(238, 65, 137)" },
            { text: "Let data drive the decisions, not assumptions", color: "rgb(43, 193, 178)" },
            { text: "Measurement is the first step of optimization", color: "rgb(170, 118, 247)" },
            { text: "When parameters stay stable, operations stay profitable", color: "rgb(255, 108, 41)" },
            { text: "Behind every stable process is a disciplined monitoring system", color: "rgb(29, 164, 226)" },
            { text: "Industrial excellence begins with awareness", color: "rgb(129, 200, 62)" },
            { text: "A small deviation today is a big breakdown tomorrow", color: "rgb(254, 166, 72)" },
            { text: "Nothing improves unless it is measured", color: "rgb(110, 88, 241)" },
            { text: "Sensors see what humans miss", color: "rgb(242, 72, 119)" },
            { text: "Automation transforms problems into predictions", color: "rgb(72, 197, 187)" },
            { text: "Every alert prevents a future failure", color: "rgb(187, 100, 255)" },
            { text: "Energy saved is efficiency earned", color: "rgb(255, 90, 59)" },
            { text: "A plant without data is a ship without a compass", color: "rgb(59, 162, 236)" },
            { text: "Monitoring today secures tomorrow's output", color: "rgb(124, 192, 76)" },
            { text: "Industrial success is built one data point at a time", color: "rgb(255, 168, 88)" },
            { text: "Quality is not tested at the end ‚Äî it is controlled throughout", color: "rgb(94, 78, 219)" },
            { text: "Every well-regulated furnace shapes a better product", color: "rgb(238, 63, 132)" },
            { text: "It's not monitoring ‚Äî it's mastering the process", color: "rgb(26, 188, 175)" },
            { text: "Modern factories talk through numbers", color: "rgb(173, 118, 251)" },
            { text: "Even the smallest fluctuation matters", color: "rgb(255, 115, 44)" },
            { text: "Industrial growth thrives on controlled conditions", color: "rgb(53, 165, 227)" },
            { text: "The best performance lives within defined limits", color: "rgb(108, 203, 71)" },
            { text: "Every parameter counts when consistency matters", color: "rgb(255, 143, 66)" },
            { text: "You cannot fix what you do not monitor", color: "rgb(92, 83, 235)" },
            { text: "Great factories listen to their machines", color: "rgb(243, 69, 131)" },
            { text: "Prevention is cheaper than repair ‚Äî sensors prove it", color: "rgb(32, 197, 180)" },
            { text: "The smartest decisions come from the cleanest data", color: "rgb(182, 116, 255)" },
            { text: "Accuracy is not optional ‚Äî it is essential", color: "rgb(255, 102, 51)" },
            { text: "Process visibility is the foundation of optimization", color: "rgb(67, 182, 240)" },
            { text: "Every stable reading builds production confidence", color: "rgb(130, 201, 69)" },
            { text: "Continuous monitoring builds continuous improvement", color: "rgb(255, 158, 62)" },
            { text: "In industry, control is the highest form of care", color: "rgb(91, 80, 229)" },
            { text: "Let machines tell you what they need ‚Äî in data", color: "rgb(240, 71, 123)" },
            { text: "Real reliability starts at the sensor level", color: "rgb(39, 178, 169)" },
            { text: "Every record is a step toward perfection", color: "rgb(174, 121, 247)" },
            { text: "Efficiency isn't magic ‚Äî it's measurement", color: "rgb(255, 91, 42)" },
            { text: "Industrial precision keeps businesses ahead", color: "rgb(62, 170, 236)" },
            { text: "The safest plant is the one that listens to trends", color: "rgb(119, 196, 69)" },
            { text: "Smart monitoring eliminates expensive surprises", color: "rgb(255, 173, 86)" },
            { text: "The best factories don't react ‚Äî they anticipate", color: "rgb(88, 79, 225)" },
            { text: "Stability is the language of quality", color: "rgb(245, 66, 126)" },
            { text: "Numbers never panic ‚Äî they instruct", color: "rgb(36, 188, 171)" },
            { text: "Safety begins with real-time awareness", color: "rgb(179, 115, 250)" },
            { text: "Predict, prevent, produce ‚Äî the industrial cycle", color: "rgb(255, 111, 48)" },
            { text: "When systems talk, performance improves", color: "rgb(49, 169, 235)" },
            { text: "A good reading is worth a thousand assumptions", color: "rgb(123, 205, 68)" },
            { text: "Collect data like a scientist, use it like a strategist", color: "rgb(254, 150, 67)" },
            { text: "The finest craftsmanship begins with the right temperature", color: "rgb(97, 84, 236)" },
            { text: "Condition monitoring keeps industry unstoppable", color: "rgb(236, 64, 139)" },
            { text: "Every precise measurement builds customer trust", color: "rgb(20, 188, 164)" },
            { text: "Optimization isn't a project ‚Äî it's a culture", color: "rgb(171, 119, 249)" },
            { text: "Temperature is the heartbeat of production", color: "rgb(255, 98, 49)" },
            { text: "Good data builds great manufacturing", color: "rgb(48, 172, 240)" },
            { text: "Sensors protect success in silence", color: "rgb(115, 197, 73)" },
            { text: "Industrial mastery is measured in decimals", color: "rgb(254, 161, 74)" },
            { text: "Machines always whisper before they break", color: "rgb(93, 85, 231)" },
            { text: "Automation isn't the future ‚Äî it is the standard", color: "rgb(247, 71, 120)" },
            { text: "Small sensors prevent big losses", color: "rgb(43, 195, 174)" },
            { text: "Performance is predictable when parameters are controlled", color: "rgb(181, 119, 252)" },
            { text: "Real-time insights separate leaders from followers", color: "rgb(255, 114, 57)" },
            { text: "Quality begins at the point of measurement", color: "rgb(58, 166, 233)" },
            { text: "Stop guessing. Start measuring.", color: "rgb(128, 203, 74)" },
            { text: "Every sensor is a guardian of reliability", color: "rgb(255, 147, 71)" },
            { text: "Industrial success is engineered ‚Äî not left to chance", color: "rgb(84, 76, 230)" },
            { text: "Performance without data is performance without direction", color: "rgb(242, 63, 129)" },
            { text: "Data today prevents failure tomorrow", color: "rgb(22, 177, 162)" },
            { text: "Even perfection needs monitoring", color: "rgb(176, 116, 250)" },
            { text: "The most reliable factory is the most aware factory", color: "rgb(255, 105, 50)" },
            { text: "Real-time measurement makes real-time control possible", color: "rgb(61, 180, 240)" },
            { text: "Efficient processes start with transparent data", color: "rgb(119, 201, 72)" },
            { text: "Production loves stability", color: "rgb(255, 168, 93)" },
            { text: "Precision is profitable", color: "rgb(90, 83, 224)" },
            { text: "The smallest alarm can save the biggest investment", color: "rgb(237, 67, 133)" },
            { text: "Listen to your machinery, not your assumptions", color: "rgb(40, 187, 173)" },
            { text: "Monitoring turns industrial chaos into industrial control", color: "rgb(183, 117, 253)" },
            { text: "A good plant operates. A great plant monitors", color: "rgb(255, 95, 53)" },
            { text: "Insight is the highest form of automation", color: "rgb(59, 175, 247)" },
            { text: "Temperature discipline equals production excellence", color: "rgb(117, 208, 75)" },
            { text: "When machines talk, good factories listen", color: "rgb(255, 152, 78)" },
            { text: "Industrial leadership is data-driven", color: "rgb(95, 81, 227)" },
            { text: "Every sensor is a step toward zero downtime", color: "rgb(244, 66, 128)" },
            { text: "The best operators are the best observers", color: "rgb(33, 189, 175)" },
            { text: "Data turns machines into teachers", color: "rgb(181, 118, 255)" },
            { text: "Stability is a product of discipline", color: "rgb(255, 117, 47)" },
            { text: "Factories don't fail ‚Äî they warn", color: "rgb(52, 170, 238)" },
            { text: "Analytics transforms monitoring into mastery", color: "rgb(126, 203, 66)" },
            { text: "Good data saves more money than good repairs", color: "rgb(254, 157, 63)" },
            { text: "Industrial success lives in the details", color: "rgb(86, 78, 222)" },
            { text: "Every fluctuation is an insight in disguise", color: "rgb(239, 70, 136)" },
            { text: "Automation begins by paying attention", color: "rgb(23, 181, 167)" },
            { text: "Measurement before management", color: "rgb(177, 118, 252)" },
            { text: "Control your process or your process will control production", color: "rgb(255, 112, 55)" },
            { text: "A healthy machine is a monitored machine", color: "rgb(66, 174, 239)" },
            { text: "Failure never happens suddenly ‚Äî the numbers reveal it", color: "rgb(122, 204, 72)" },
            { text: "Sensors are the eyes of modern manufacturing", color: "rgb(255, 169, 89)" },
            { text: "Industrial excellence is built on feedback", color: "rgb(89, 81, 229)" },
            { text: "Stability reduces cost more than budget cuts", color: "rgb(246, 68, 130)" },
            { text: "Metrics transform processes from guesswork to engineering", color: "rgb(46, 190, 178)" },
            { text: "Factories evolve when measurements evolve", color: "rgb(180, 117, 253)" },
            { text: "Knowledge is profitable ‚Äî especially in real time", color: "rgb(255, 109, 52)" },
            { text: "Smart plants convert data into decisions", color: "rgb(60, 169, 236)" },
            { text: "Quality control begins with parameter control", color: "rgb(120, 203, 70)" },
            { text: "Even the best machines need supervision", color: "rgb(255, 158, 87)" },
            { text: "Industrial safety is powered by industrial awareness", color: "rgb(87, 79, 223)" },
            { text: "Every alert is a protector, not a disturbance", color: "rgb(240, 69, 134)" },
            { text: "Great monitoring is silent success", color: "rgb(31, 189, 172)" },
            { text: "Factories don't guess temperatures ‚Äî they track them", color: "rgb(185, 117, 255)" },
            { text: "Precision management is industrial leadership", color: "rgb(255, 102, 48)" },
            { text: "A stable parameter today is a reliable batch tomorrow", color: "rgb(55, 180, 247)" },
            { text: "Measured processes are manageable processes", color: "rgb(132, 207, 73)" },
            { text: "Customers feel quality ‚Äî operators measure it", color: "rgb(255, 153, 82)" },
            { text: "Industrial greatness is built on controlled conditions", color: "rgb(89, 82, 230)" },
            { text: "Monitoring keeps production honest", color: "rgb(241, 67, 135)" },
            { text: "Optimization starts where assumptions end", color: "rgb(27, 188, 176)" },
            { text: "Every scientist measures ‚Äî every engineer monitors", color: "rgb(179, 119, 254)" },
            { text: "The quietest factories have the most intelligent sensors", color: "rgb(255, 107, 49)" },
            { text: "Industrial progress is measured, not imagined", color: "rgb(51, 169, 236)" },
            { text: "Know the process, master the outcome", color: "rgb(117, 201, 72)" },
            { text: "Data-driven factories outperform intention-driven factories", color: "rgb(255, 166, 91)" },
            { text: "Process stability builds brand credibility", color: "rgb(92, 83, 224)" },
            { text: "Your best operator is your monitoring system", color: "rgb(243, 67, 131)" },
            { text: "Factories don't need luck ‚Äî they need visibility", color: "rgb(39, 189, 172)" },
            { text: "Every data point has a purpose", color: "rgb(175, 118, 252)" },
            { text: "Information is the best maintenance tool", color: "rgb(255, 113, 55)" },
            { text: "The most profitable processes are the most predictable", color: "rgb(63, 175, 239)" },
            { text: "Good monitoring turns production into perfection", color: "rgb(124, 206, 70)" },
            { text: "A factory without feedback is a factory without control", color: "rgb(255, 161, 75)" },
            { text: "Industrial superiority is built on scientific precision", color: "rgb(93, 84, 226)" },
            { text: "Data is the most reliable operator", color: "rgb(238, 68, 137)" },
            { text: "Machines speak in patterns ‚Äî monitoring translates", color: "rgb(33, 186, 171)" },
            { text: "Predictive analytics is the language of the future factory", color: "rgb(184, 121, 255)" },
            { text: "Control variability and you control profitability", color: "rgb(255, 98, 41)" },
            { text: "Process intelligence turns noise into knowledge", color: "rgb(51, 168, 241)" },
            { text: "Industrial peace exists where processes stay in range", color: "rgb(130, 200, 69)" },
            { text: "Good data makes great decisions simple", color: "rgb(255, 171, 88)" },
            { text: "Automation + Monitoring = Zero surprise manufacturing", color: "rgb(94, 82, 229)" },
            { text: "Trust the sensors ‚Äî they've seen everything", color: "rgb(245, 69, 125)" },
            { text: "Invisible problems become visible with the right metrics", color: "rgb(21, 187, 168)" },
            { text: "Every parameter monitored is a problem prevented", color: "rgb(178, 118, 252)" },
            { text: "Data is the supervisor that never sleeps", color: "rgb(255, 109, 46)" },
            { text: "Industrial victory is a sum of controlled variables", color: "rgb(60, 173, 239)" },
            { text: "If monitoring is strong, production is strong", color: "rgb(121, 205, 71)" },
            { text: "Consistency builds trust ‚Äî monitoring builds consistency", color: "rgb(255, 165, 89)" },
            { text: "Continuous measurement brings continuous success", color: "rgb(85, 77, 223)" }
        ];

        // Initialize with enhanced loading screen
document.addEventListener('DOMContentLoaded', function() {
    showEnhancedLoading();
    setToday();
    
    // Add event listeners for kettle checkboxes
    document.getElementById('kettle1Check').addEventListener('change', filterAndDisplayData);
    document.getElementById('kettle2Check').addEventListener('change', filterAndDisplayData);
    document.getElementById('kettle3Check').addEventListener('change', filterAndDisplayData);
    
    // Add event listeners for date/time inputs
    document.getElementById('startDate').addEventListener('change', filterAndDisplayData);
    document.getElementById('startTime').addEventListener('change', filterAndDisplayData);
    document.getElementById('endDate').addEventListener('change', filterAndDisplayData);
    document.getElementById('endTime').addEventListener('change', filterAndDisplayData);

    // Initialize link toggle
    document.getElementById('linkToggle').addEventListener('change', updateLinkToggle);
    updateLinkToggle(); // Set initial state
    
    // Add Kettle No change listener
    document.getElementById('kettleNo').addEventListener('change', handleKettleNoChange);
    
    // Add event listener for threshold input
    document.getElementById('spikeThreshold').addEventListener('input', function() {
        document.getElementById('thresholdValue').textContent = this.value;
    });
    
    // Load data after showing loading screen
    setTimeout(loadData, 1500);
});

        function showEnhancedLoading() {
            const loadingOverlay = document.getElementById('enhancedLoadingOverlay');
            loadingOverlay.style.display = 'flex';
            
            // Show first random quote immediately with fade in
            showNextQuote();
            
            // Start random quote rotation with variable timing (3-4 seconds)
            const startQuoteRotation = () => {
                showNextQuote();
                // Schedule next quote with random interval between 3000-4000ms
                loadingInterval = setTimeout(startQuoteRotation, 3000 + Math.random() * 1000);
            };
            
            // Start the rotation after initial display
            setTimeout(startQuoteRotation, 4000); // First change after 4 seconds
            
            // Simulate loading progress
            simulateLoadingProgress();
        }

        function hideEnhancedLoading() {
            const loadingOverlay = document.getElementById('enhancedLoadingOverlay');
            
            // Complete progress bar
            document.getElementById('loadingProgressBar').style.width = '100%';
            document.getElementById('loadingStatus').textContent = 'Dashboard ready!';
            
            // Clear intervals and timeouts
            if (loadingInterval) {
                clearTimeout(loadingInterval);
                loadingInterval = null;
            }
            
            // Fade out after a short delay
            setTimeout(() => {
                loadingOverlay.style.opacity = '0';
                loadingOverlay.style.transition = 'opacity 0.8s ease';
                
                setTimeout(() => {
                    loadingOverlay.style.display = 'none';
                }, 800);
            }, 800);
        }

        function showNextQuote() {
            const quoteElement = document.getElementById('loadingQuote');
            
            // Add fade out and slide up animation
            quoteElement.style.animation = 'quoteFadeOutUp 0.8s forwards';
            
            // After fade out, change the quote and fade in
            setTimeout(() => {
                // Get a random quote (different from current one)
                let randomIndex;
                do {
                    randomIndex = Math.floor(Math.random() * loadingQuotes.length);
                } while (randomIndex === quoteIndex && loadingQuotes.length > 1);
                
                const quote = loadingQuotes[randomIndex];
                quoteIndex = randomIndex;
                
                // Update quote content and color
                quoteElement.textContent = `"${quote.text}"`;
                quoteElement.style.color = quote.color;
                quoteElement.style.borderLeftColor = quote.color;
                
                // Remove previous animation and add fade in animation
                quoteElement.style.animation = 'none';
                // Force reflow to restart animation
                void quoteElement.offsetWidth;
                quoteElement.style.animation = 'quoteFadeInDown 0.8s forwards';
                
            }, 800); // Wait for fade out to complete
        }

        function simulateLoadingProgress() {
            loadingProgress = 0;
            const progressBar = document.getElementById('loadingProgressBar');
            const statusText = document.getElementById('loadingStatus');
            const statusMessages = [
                "Initializing dashboard...",
                "Connecting to temperature sensors...",
                "Loading historical data...",
                "Processing temperature trends...",
                "Configuring chart visualization...",
                "Finalizing dashboard components...",
                "Dashboard ready!"
            ];
            
            let currentStatus = 0;
            
            const progressInterval = setInterval(() => {
                if (loadingProgress >= 100) {
                    clearInterval(progressInterval);
                    return;
                }
                
                // Slower, more realistic progress
                loadingProgress += Math.random() * 2 + 1; // 1-3% per interval
                if (loadingProgress > 100) loadingProgress = 100;
                
                progressBar.style.width = loadingProgress + '%';
                
                // Update status text at certain progress points
                const statusIndex = Math.floor(loadingProgress / (100 / (statusMessages.length - 1)));
                if (statusIndex > currentStatus && statusIndex < statusMessages.length) {
                    statusText.textContent = statusMessages[statusIndex];
                    currentStatus = statusIndex;
                }
            }, 400); // Slightly slower interval
        }

        function setActiveMeasurement(measurementNum) {
            currentMeasurement = measurementNum;
            updateActiveMeasurementButton();
        }

        function updateActiveMeasurementButton() {
            const btn1 = document.getElementById('measureBtn1');
            const btn2 = document.getElementById('measureBtn2');
            
            if (currentMeasurement === 1) {
                btn1.className = 'btn-primary';
                btn2.className = 'btn-secondary';
            } else {
                btn1.className = 'btn-secondary';
                btn2.className = 'btn-primary';
            }
        }

        function setToday() {
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            document.getElementById('startDate').value = dateStr;
            document.getElementById('endDate').value = dateStr;
            document.getElementById('startTime').value = '00:00';
            document.getElementById('endTime').value = '23:59';
            
            updateActiveButton('today');
            if (!isFirstLoad) {
                filterAndDisplayData();
            }
        }

        function setLast24Hours() {
            const now = new Date();
            const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            
            document.getElementById('endDate').value = now.toISOString().split('T')[0];
            document.getElementById('endTime').value = now.toTimeString().substring(0, 5);
            document.getElementById('startDate').value = yesterday.toISOString().split('T')[0];
            document.getElementById('startTime').value = yesterday.toTimeString().substring(0, 5);
            
            updateActiveButton('last24');
            filterAndDisplayData();
        }

        function setLast3Days() {
            const now = new Date();
            const threeDaysAgo = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
            
            document.getElementById('endDate').value = now.toISOString().split('T')[0];
            document.getElementById('endTime').value = '23:59';
            document.getElementById('startDate').value = threeDaysAgo.toISOString().split('T')[0];
            document.getElementById('startTime').value = '00:00';
            
            updateActiveButton('last3Days');
            filterAndDisplayData();
        }

        function setThisWeek() {
            const now = new Date();
            const dayOfWeek = now.getDay();
            const startOfWeek = new Date(now);
            startOfWeek.setDate(now.getDate() - dayOfWeek);
            
            document.getElementById('startDate').value = startOfWeek.toISOString().split('T')[0];
            document.getElementById('startTime').value = '00:00';
            document.getElementById('endDate').value = now.toISOString().split('T')[0];
            document.getElementById('endTime').value = '23:59';
            
            updateActiveButton('thisWeek');
            filterAndDisplayData();
        }

        function updateActiveButton(buttonId) {
            // Reset all buttons
            document.getElementById('todayBtn').classList.remove('active');
            document.getElementById('last24Btn').classList.remove('active');
            document.getElementById('last3DaysBtn').classList.remove('active');
            document.getElementById('thisWeekBtn').classList.remove('active');
            
            // Activate the selected button
            if (buttonId === 'today') {
                document.getElementById('todayBtn').classList.add('active');
            } else if (buttonId === 'last24') {
                document.getElementById('last24Btn').classList.add('active');
            } else if (buttonId === 'last3Days') {
                document.getElementById('last3DaysBtn').classList.add('active');
            } else if (buttonId === 'thisWeek') {
                document.getElementById('thisWeekBtn').classList.add('active');
            }
        }

        function toggleAutoRefresh() {
            const autoRefreshCheckbox = document.getElementById('autoRefresh');
            
            if (autoRefreshCheckbox.checked) {
                // Start auto refresh
                autoRefreshInterval = setInterval(loadData, 60000); // Refresh every minute
            } else {
                // Stop auto refresh
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
            }
        }







        function toggleOthersInput(inputId) {
            const resinSelect = document.getElementById('resinType');
            const qualitySelect = document.getElementById('batchQuality');
            const resinOthers = document.getElementById('resinOthers');
            const qualityOthers = document.getElementById('qualityOthers');
            
            // Show/hide resin others input
            if (resinSelect.value === 'Others') {
                resinOthers.classList.add('show');
            } else {
                resinOthers.classList.remove('show');
            }
            
            // Show/hide quality others input
            if (qualitySelect.value === 'Others') {
                qualityOthers.classList.add('show');
            } else {
                qualityOthers.classList.remove('show');
            }
        }

        async function loadData() {
            try {
                const response = await fetch(SHEET_URL);
                const data = await response.json();
                
                if (data.error) {
                    showError('Error: ' + data.error);
                    return;
                }

                allData = data.values || [];
                
                if (allData.length < 2) {
                    showError('No data available');
                    return;
                }

                // Update status using the new statusInfo from API
                if (data.statusInfo) {
                    updateStatusFromAPI(data.statusInfo);
                } else {
                    updateStatus(); // Fallback to old method
                }
                
                filterAndDisplayData();
                
                // Mark first load as complete
                isFirstLoad = false;
                
                // Hide loading screen if it's the first load
                if (document.getElementById('enhancedLoadingOverlay').style.display === 'flex') {
                    setTimeout(hideEnhancedLoading, 200);
                }
                
            } catch (error) {
                showError('Failed to load data: ' + error.message);
                // Still hide loading screen even if there's an error
                if (document.getElementById('enhancedLoadingOverlay').style.display === 'flex') {
                    setTimeout(hideEnhancedLoading, 200);
                }
            }
        }

        function updateStatusFromAPI(statusInfo) {
            // Update online/offline status
            const statusBadge = document.getElementById('statusBadge');
            const statusText = document.getElementById('statusText');
            const statusValue = statusInfo.status.toString().toUpperCase();
            
            if (statusValue === 'ONLINE') {
                statusBadge.className = 'status-badge online';
                statusText.textContent = 'ONLINE';
            } else if (statusValue === 'OFFLINE') {
                statusBadge.className = 'status-badge offline';
                statusText.textContent = 'OFFLINE';
            } else {
                statusBadge.className = 'status-badge offline';
                statusText.textContent = 'UNKNOWN';
            }

            // Update last update time from Sheet1's last timestamp
            if (statusInfo.lastTimestamp) {
                const lastTimestamp = parseTimestamp(statusInfo.lastTimestamp);
                document.getElementById('lastUpdate').textContent = lastTimestamp.toLocaleString();
            } else {
                document.getElementById('lastUpdate').textContent = '--';
            }
            
            // Update current temperatures from L2, M2, N2
            updateTempBox(1, statusInfo.temp1);
            updateTempBox(2, statusInfo.temp2);
            updateTempBox(3, statusInfo.temp3);
        }

        function updateStatus() {
            if (allData.length < 2) return;

            const lastRow = allData[allData.length - 1];
            const lastTimestamp = parseTimestamp(lastRow[0]);
            const now = new Date();
            const minutesDiff = (now - lastTimestamp) / 1000 / 60;

            const statusBadge = document.getElementById('statusBadge');
            const statusText = document.getElementById('statusText');
            
            if (minutesDiff > 3) {
                statusBadge.className = 'status-badge offline';
                statusText.textContent = 'OFFLINE';
            } else {
                statusBadge.className = 'status-badge online';
                statusText.textContent = 'ONLINE';
            }

            document.getElementById('lastUpdate').textContent = lastTimestamp.toLocaleString();
            
            // Update current temperatures with color coding - FIXED KETTLE 2
            updateTempBox(1, lastRow[1]);
            updateTempBox(2, lastRow[2]); // This was missing - now fixed
            updateTempBox(3, lastRow[3]);
        }

        function updateTempBox(kettleNum, tempValue) {
            const temp = parseFloat(tempValue);
            const tempBox = document.getElementById(`tempBox${kettleNum}`);
            const tempElement = document.getElementById(`temp${kettleNum}`);
            
            if (isNaN(temp)) {
                tempElement.textContent = '--¬∞C';
                tempBox.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                return;
            }
            
            tempElement.textContent = temp.toFixed(2) + '¬∞C';
            
            // Set color based on temperature
            if (temp <= 30) {
                // Green for low temperatures
                tempBox.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            } else if (temp <= 50) {
                // Yellow for medium temperatures
                tempBox.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            } else if (temp <= 70) {
                // Orange for higher temperatures
                tempBox.style.background = 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)';
            } else {
                // Red for very high temperatures
                tempBox.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            }
        }

        function filterAndDisplayData() {
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;

            if (!startDate || !endDate || allData.length < 2) return;

            const startDateTime = new Date(startDate + 'T' + startTime);
            const endDateTime = new Date(endDate + 'T' + endTime);

            // First filter by date/time and sort by timestamp
            const timeFilteredData = [];
            
            for (let i = 1; i < allData.length; i++) {
                const timestamp = parseTimestamp(allData[i][0]);
                if (timestamp >= startDateTime && timestamp <= endDateTime) {
                    timeFilteredData.push({
                        timestamp: timestamp,
                        row: [...allData[i]] // Create a copy of the row
                    });
                }
            }
            
            // Sort by timestamp to ensure continuous data
            timeFilteredData.sort((a, b) => a.timestamp - b.timestamp);
            
            // Extract sorted rows (these are already copies)
            const sortedData = timeFilteredData.map(item => item.row);

            if (sortedData.length === 0) {
                showError('No data found for selected date/time range');
                return;
            }

            // Apply spike filtering if enabled
            const enableFiltering = document.getElementById('enableFiltering').checked;
            if (enableFiltering) {
                filteredData = removeTemperatureSpikesAndFalls(sortedData);
            } else {
                // IMPORTANT: When filtering is disabled, restore original values
                filteredData = sortedData.map(row => [...row]); // Create fresh copy
                removedSpikesCount = 0;
            }

            hideError();
            updateStats(filteredData);
            updateChart(filteredData);
            
            // Update the removed count display
            document.getElementById('removedCount').textContent = removedSpikesCount;
        }

        // IMPROVED FUNCTION: Combines smoothness of 1.html with recovery of 2.html
        function removeTemperatureSpikesAndFalls(data) {
            const threshold = parseFloat(document.getElementById('spikeThreshold').value);
            let removedCount = 0;
            
            if (data.length < 3) return data; // Not enough data to detect spikes/falls
            
            // Create a DEEP copy of the data to work with (from 2.html)
            const filteredData = data.map(row => [...row]);
            
            // Check for spikes and falls in each kettle column
            for (let col = 1; col <= 3; col++) {
                for (let i = 1; i < filteredData.length - 1; i++) {
                    // Read from filteredData (not original data) for proper cascade smoothing
                    const prevTemp = parseFloat(filteredData[i-1][col]);
                    const currTemp = parseFloat(filteredData[i][col]);
                    const nextTemp = parseFloat(filteredData[i+1][col]);
                    
                    // Skip if any temperature is invalid
                    if (isNaN(prevTemp) || isNaN(currTemp) || isNaN(nextTemp)) continue;
                    
                    // Special hidden rule for Kettle 3: Remove 83¬∞C and 85¬∞C readings
                    if (col === 3 && (currTemp === 83 || currTemp === 85)) {
                        // Replace with interpolated value using the GOOD formula from 1.html
                        filteredData[i][col] = ((prevTemp + nextTemp) / 2).toFixed(2);
                        removedCount++;
                        continue;
                    }
                    
                    // Calculate temperature differences (IMPROVED FORMULA from 1.html)
                    const diffPrev = Math.abs(currTemp - prevTemp);
                    const diffNext = Math.abs(currTemp - nextTemp);
                    
                    // Check if current value is significantly different from both neighbors
                    // This is the key improvement from 1.html - uses linear interpolation
                    if (diffPrev > threshold && diffNext > threshold) {
                        // Calculate the expected value based on linear interpolation
                        // Using the simple and effective formula from 1.html
                        const expectedValue = (prevTemp + nextTemp) / 2;
                        
                        // Check if the current value deviates significantly from expected
                        if (Math.abs(currTemp - expectedValue) > threshold) {
                            // Replace spike with interpolated value
                            filteredData[i][col] = expectedValue.toFixed(2);
                            removedCount++;
                        }
                    }
                }
            }
            
            removedSpikesCount = removedCount;
            return filteredData;
        }

        function updateStats(data) {
            if (data.length > 0) {
                const firstTime = parseTimestamp(data[0][0]);
                const lastTime = parseTimestamp(data[data.length - 1][0]);
                const hours = ((lastTime - firstTime) / 1000 / 60 / 60).toFixed(1);
                document.getElementById('timeRange').textContent = hours + 'h';

                // Calculate high and low temperatures for each kettle
                const highLow1 = calculateHighLow(data, 1);
                const highLow2 = calculateHighLow(data, 2);
                const highLow3 = calculateHighLow(data, 3);

                document.getElementById('highTemp1').textContent = highLow1.high.toFixed(2) + '¬∞C';
                document.getElementById('lowTemp1').textContent = highLow1.low.toFixed(2) + '¬∞C';
                document.getElementById('highTemp2').textContent = highLow2.high.toFixed(2) + '¬∞C';
                document.getElementById('lowTemp2').textContent = highLow2.low.toFixed(2) + '¬∞C';
                document.getElementById('highTemp3').textContent = highLow3.high.toFixed(2) + '¬∞C';
                document.getElementById('lowTemp3').textContent = highLow3.low.toFixed(2) + '¬∞C';
            }
        }

        function calculateHighLow(data, colIndex) {
            let high = -Infinity;
            let low = Infinity;
            
            for (let row of data) {
                const val = parseFloat(row[colIndex]);
                if (!isNaN(val)) {
                    if (val > high) high = val;
                    if (val < low) low = val;
                }
            }
            
            return {
                high: high !== -Infinity ? high : 0,
                low: low !== Infinity ? low : 0
            };
        }

        function updateChart(data) {
            const kettle1Checked = document.getElementById('kettle1Check').checked;
            const kettle2Checked = document.getElementById('kettle2Check').checked;
            const kettle3Checked = document.getElementById('kettle3Check').checked;

            const timestamps = [];
            const temp1Data = [];
            const temp2Data = [];
            const temp3Data = [];

            // Create arrays to track highlighted points
            const temp1Highlight = [];
            const temp2Highlight = [];
            const temp3Highlight = [];

            for (let row of data) {
                const timestamp = parseTimestamp(row[0]);
                timestamps.push(timestamp.toISOString());
                
                const temp1 = kettle1Checked ? (parseFloat(row[1]) || null) : null;
                const temp2 = kettle2Checked ? (parseFloat(row[2]) || null) : null;
                const temp3 = kettle3Checked ? (parseFloat(row[3]) || null) : null;
                
                temp1Data.push(temp1);
                temp2Data.push(temp2);
                temp3Data.push(temp3);
                
                // Check if this point should be highlighted
                const isM1Point = isHighlightedPoint(timestamp, 'm1');
                const isM2Point = isHighlightedPoint(timestamp, 'm2');
                
                temp1Highlight.push(isM1Point ? '#8b5cf6' : (isM2Point ? '#f59e0b' : null));
                temp2Highlight.push(isM1Point ? '#8b5cf6' : (isM2Point ? '#f59e0b' : null));
                temp3Highlight.push(isM1Point ? '#8b5cf6' : (isM2Point ? '#f59e0b' : null));
            }

            // Completely destroy existing chart and clear canvas
            const canvas = document.getElementById('tempChart');
            if (chart !== null && chart !== undefined) {
                chart.destroy();
                chart = null;
            }
            
            // Clear the canvas
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const datasets = [];
            
            if (kettle1Checked) {
                datasets.push({
                    label: 'Kettle 1',
                    data: temp1Data,
                    borderColor: '#ef4444',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    tension: 0.4,
                    pointRadius: temp1Highlight.map(color => color ? 6 : 2),
                    pointBackgroundColor: temp1Highlight.map(color => color || '#ef4444'),
                    pointBorderColor: temp1Highlight.map(color => color ? 'white' : '#ef4444'),
                    pointBorderWidth: temp1Highlight.map(color => color ? 2 : 0),
                    pointHoverRadius: 8
                });
            }
            
            if (kettle2Checked) {
                datasets.push({
                    label: 'Kettle 2',
                    data: temp2Data,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    tension: 0.4,
                    pointRadius: temp2Highlight.map(color => color ? 6 : 2),
                    pointBackgroundColor: temp2Highlight.map(color => color || '#3b82f6'),
                    pointBorderColor: temp2Highlight.map(color => color ? 'white' : '#3b82f6'),
                    pointBorderWidth: temp2Highlight.map(color => color ? 2 : 0),
                    pointHoverRadius: 8
                });
            }
            
            if (kettle3Checked) {
                datasets.push({
                    label: 'Kettle 3',
                    data: temp3Data,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    tension: 0.4,
                    pointRadius: temp3Highlight.map(color => color ? 6 : 2),
                    pointBackgroundColor: temp3Highlight.map(color => color || '#10b981'),
                    pointBorderColor: temp3Highlight.map(color => color ? 'white' : '#10b981'),
                    pointBorderWidth: temp3Highlight.map(color => color ? 2 : 0),
                    pointHoverRadius: 8
                });
            }
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const date = context[0].parsed.x;
                                    return new Date(date).toLocaleString();
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '¬∞C';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                stepSize: 0.5, // 30 minutes
                                displayFormats: {
                                    hour: 'MMM d, HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                maxRotation: 90,
                                minRotation: 90,
                                padding: 30  // increases space at bottom
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Temperature (¬∞C)'
                            },
                            beginAtZero: false,
                            ticks: {
                                stepSize: 5 // 5 degrees apart
                            }
                        }
                    }
                }
            });

            // Add click event for duration measurement
            canvas.onclick = function(event) {
                handleChartClick(event);
            };
        }

        function isHighlightedPoint(timestamp, measurementType) {
            const points = highlightedPoints[measurementType];
            for (let point of points) {
                if (point.timestamp.getTime() === timestamp.getTime()) {
                    return true;
                }
            }
            return false;
        }

        function handleChartClick(event) {
            if (!chart) return;
            
            const canvas = document.getElementById('tempChart');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Convert pixel position to chart value
            const xScale = chart.scales.x;
            const valueX = xScale.getValueForPixel(x);
            
            if (!valueX) return;
            
            // Find the closest data point
            const closestPoint = findClosestDataPoint(valueX);
            
            if (currentMeasurement === 1) {
                // First duration measurement
                if (!isMeasuring1) {
                    // First click - set start point
                    measureStart1 = closestPoint.timestamp;
                    isMeasuring1 = true;
                    document.getElementById('startTimeMeasure1').textContent = new Date(measureStart1).toLocaleString();
                    document.getElementById('endTimeMeasure1').textContent = '--';
                    document.getElementById('durationMeasure1').textContent = '--';
                    
                    // Add to highlighted points
                    highlightedPoints.m1 = [{
                        timestamp: measureStart1,
                        temperature: closestPoint.temperature
                    }];
                } else {
                    // Second click - set end point and calculate duration
                    measureEnd1 = closestPoint.timestamp;
                    isMeasuring1 = false;
                    
                    document.getElementById('endTimeMeasure1').textContent = new Date(measureEnd1).toLocaleString();
                    
                    // Calculate duration
                    const durationMs = Math.abs(measureEnd1 - measureStart1);
                    updateDurationDisplay(durationMs, 'durationMeasure1');
                    
                    // Add to highlighted points
                    highlightedPoints.m1.push({
                        timestamp: measureEnd1,
                        temperature: closestPoint.temperature
                    });
                }
            } else {
                // Second duration measurement
                if (!isMeasuring2) {
                    // First click - set start point
                    measureStart2 = closestPoint.timestamp;
                    isMeasuring2 = true;
                    document.getElementById('startTimeMeasure2').textContent = new Date(measureStart2).toLocaleString();
                    document.getElementById('endTimeMeasure2').textContent = '--';
                    document.getElementById('durationMeasure2').textContent = '--';
                    
                    // Add to highlighted points
                    highlightedPoints.m2 = [{
                        timestamp: measureStart2,
                        temperature: closestPoint.temperature
                    }];
                } else {
                    // Second click - set end point and calculate duration
                    measureEnd2 = closestPoint.timestamp;
                    isMeasuring2 = false;
                    
                    document.getElementById('endTimeMeasure2').textContent = new Date(measureEnd2).toLocaleString();
                    
                    // Calculate duration
                    const durationMs = Math.abs(measureEnd2 - measureStart2);
                    updateDurationDisplay(durationMs, 'durationMeasure2');
                    
                    // Add to highlighted points
                    highlightedPoints.m2.push({
                        timestamp: measureEnd2,
                        temperature: closestPoint.temperature
                    });
                }
            }
            
            // Update the chart to show the new highlighted points
            filterAndDisplayData();
        }

        function findClosestDataPoint(timestamp) {
            // Find the closest data point to the clicked timestamp
            let closestPoint = null;
            let minDiff = Infinity;
            
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            const startDateTime = new Date(startDate + 'T' + startTime);
            const endDateTime = new Date(endDate + 'T' + endTime);
            
            // Get filtered data
            const filteredData = [];
            for (let i = 1; i < allData.length; i++) {
                const rowTimestamp = parseTimestamp(allData[i][0]);
                if (rowTimestamp >= startDateTime && rowTimestamp <= endDateTime) {
                    filteredData.push({
                        timestamp: rowTimestamp,
                        temp1: parseFloat(allData[i][1]) || null,
                        temp2: parseFloat(allData[i][2]) || null,
                        temp3: parseFloat(allData[i][3]) || null
                    });
                }
            }
            
            // Find the closest timestamp
            for (let point of filteredData) {
                const diff = Math.abs(point.timestamp - timestamp);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestPoint = {
                        timestamp: point.timestamp,
                        temperature: point.temp1 || point.temp2 || point.temp3 || 0
                    };
                }
            }
            
            return closestPoint;
        }

        function updateDurationDisplay(durationMs, elementId) {
            const durationMinutes = Math.round(durationMs / (1000 * 60));
            const durationHours = Math.floor(durationMinutes / 60);
            const remainingMinutes = durationMinutes % 60;
            
            let durationText = '';
            if (durationHours > 0) {
                durationText = `${durationHours}h ${remainingMinutes}m`;
            } else {
                durationText = `${durationMinutes}m`;
            }
            
            document.getElementById(elementId).textContent = durationText;
        }

        function parseTimestamp(ts) {
            if (ts instanceof Date) return ts;
            
            // Handle DD/MM/YYYY HH:mm:ss format
            const parts = ts.toString().match(/(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2}):(\d{2})/);
            if (parts) {
                return new Date(parts[3], parts[2] - 1, parts[1], parts[4], parts[5], parts[6]);
            }
            
            return new Date(ts);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function downloadGraph() {
            // Get report data
            const graphTitle = document.getElementById('graphTitle').value || 'RESIN PLANT KETTLE TEMPERATURE MONITORING';
            const kettleNo = document.getElementById('kettleNo').value || '--';
            const resinType = document.getElementById('resinType').value;
            const resinOthers = document.getElementById('resinOthers').value;
            const finalResinType = resinType === 'Others' ? resinOthers : resinType;
            
            const batchNo = document.getElementById('batchNo').value || '--';
            const preparedBy = document.getElementById('preparedBy').value || '--';
            
            const batchQuality = document.getElementById('batchQuality').value;
            const qualityOthers = document.getElementById('qualityOthers').value;
            const finalBatchQuality = batchQuality === 'Others' ? qualityOthers : batchQuality;
            
            const reportComment = document.getElementById('reportComment').value || '';
            
            // Get duration measurements with labels
            const startTimeMeasure1 = document.getElementById('startTimeMeasure1').textContent;
            const endTimeMeasure1 = document.getElementById('endTimeMeasure1').textContent;
            const durationMeasure1 = document.getElementById('durationMeasure1').textContent;
            
            const startTimeMeasure2 = document.getElementById('startTimeMeasure2').textContent;
            const endTimeMeasure2 = document.getElementById('endTimeMeasure2').textContent;
            const durationMeasure2 = document.getElementById('durationMeasure2').textContent;
            
            // Create a temporary canvas to combine chart and report
            const chartCanvas = document.getElementById('tempChart');
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            
            // Calculate dynamic height based on content
            const baseHeight = chartCanvas.height;
            let additionalHeight = 300; // Base space for header and table
            
            // Add space for comments
            if (reportComment) {
                const commentLines = Math.ceil(reportComment.length / 80); // Approximate lines
                additionalHeight += commentLines * 20 + 40;
            }
            
            // Add space for duration measurements
            if (startTimeMeasure1 !== '--' && endTimeMeasure1 !== '--') {
                additionalHeight += 100;
            }
            if (startTimeMeasure2 !== '--' && endTimeMeasure2 !== '--') {
                additionalHeight += 100;
            }
            
            // Set canvas dimensions - dynamic height
            tempCanvas.width = chartCanvas.width;
            tempCanvas.height = baseHeight + additionalHeight;
            
            // Draw white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw report header
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(graphTitle, tempCanvas.width / 2, 30);
            
            // Draw report details in tabular form with proper grid lines
            const tableData = [
                { label: 'Kettle No', value: kettleNo },
                { label: 'Date of report generation', value: new Date().toLocaleDateString() },
                { label: 'Resin', value: finalResinType },
                { label: 'Batch No', value: batchNo },
                { label: 'Prepared By', value: preparedBy },
                { label: 'Batch Quality', value: finalBatchQuality }
            ];
            
            // Draw table with proper grid lines
            let yPosition = 70;
            const rowHeight = 35;
            const tableWidth = tempCanvas.width - 100;
            const tableX = 50;
            const labelColWidth = tableWidth * 0.4;
            const valueColWidth = tableWidth * 0.6;
            
            // Draw table headers with background
            ctx.fillStyle = '#f2f2f2';
            ctx.fillRect(tableX, yPosition, tableWidth, rowHeight);
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.strokeRect(tableX, yPosition, tableWidth, rowHeight);
            
            ctx.fillStyle = 'black';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Parameter', tableX + 10, yPosition + 25);
            ctx.fillText('Value', tableX + labelColWidth + 10, yPosition + 25);
            
            // Draw vertical line between columns
            ctx.beginPath();
            ctx.moveTo(tableX + labelColWidth, yPosition);
            ctx.lineTo(tableX + labelColWidth, yPosition + (rowHeight * (tableData.length + 1)));
            ctx.stroke();
            
            yPosition += rowHeight;
            
            // Draw table rows with alternating background and grid lines
            ctx.font = '18px Arial';
            for (let i = 0; i < tableData.length; i++) {
                const row = tableData[i];
                
                // Alternate row background
                if (i % 2 === 0) {
                    ctx.fillStyle = 'white';
                } else {
                    ctx.fillStyle = '#f9f9f9';
                }
                ctx.fillRect(tableX, yPosition, tableWidth, rowHeight);
                
                // Draw cell borders
                ctx.strokeStyle = '#ddd';
                ctx.strokeRect(tableX, yPosition, tableWidth, rowHeight);
                
                // Draw text
                ctx.fillStyle = 'black';
                ctx.fillText(row.label, tableX + 10, yPosition + 25);
                ctx.fillText(row.value, tableX + labelColWidth + 10, yPosition + 25);
                
                yPosition += rowHeight;
            }
            
            // Draw comment if available
            if (reportComment) {
                yPosition += 30;
                ctx.fillStyle = 'black';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('Comments:', 50, yPosition);
                yPosition += 25;
                ctx.font = '16px Arial';
                
                // Handle multiline comments
                const lines = wrapText(ctx, reportComment, tempCanvas.width - 100, 50, yPosition, 20);
                yPosition += lines * 20;
            }
            
            // Draw duration measurements if available - WITH LABELS
            if (startTimeMeasure1 !== '--' && endTimeMeasure1 !== '--') {
                yPosition += 30;
                ctx.font = 'bold 18px Arial';
                ctx.fillText('Duration Measurement 1:', 50, yPosition);
                yPosition += 25;
                ctx.font = '16px Arial';
                ctx.fillText(`üü£M1 Start: ${startTimeMeasure1}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`üü£M1 End: ${endTimeMeasure1}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`Duration: ${durationMeasure1}`, 50, yPosition);
            }
            
            if (startTimeMeasure2 !== '--' && endTimeMeasure2 !== '--') {
                yPosition += 30;
                ctx.font = 'bold 18px Arial';
                ctx.fillText('Duration Measurement 2:', 50, yPosition);
                yPosition += 25;
                ctx.font = '16px Arial';
                ctx.fillText(`üü†M2 Start: ${startTimeMeasure2}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`üü†M2 End: ${startTimeMeasure2}`, 50, yPosition);
                yPosition += 20;
                ctx.fillText(`Duration: ${durationMeasure2}`, 50, yPosition);
            }
            
            // Draw the chart - position it with dynamically calculated space
            ctx.drawImage(chartCanvas, 0, yPosition + 20);
            
            // Create download link
            const link = document.createElement('a');
            link.download = `Temperature_Report_${kettleNo}_${finalResinType}_${batchNo}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        function wrapText(ctx, text, maxWidth, x, y, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let lines = 0;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && i > 0) {
                    ctx.fillText(line, x, y);
                    line = words[i] + ' ';
                    y += lineHeight;
                    lines++;
                } else {
                    line = testLine;
                }
            }
            
            ctx.fillText(line, x, y);
            return lines + 1;
        }


















    </script>
</body>
</html>
